---
output:
  html_document:
    theme: sandstone
    dev: svglite
    toc: yes
    toc_depth: 3
    toc_float: true
title: "`r paste0('Season summary: ', ifelse(league == 'lonewolf', 'LoneWolf', '4545 League'), ifelse(lw_section == 'open', ' (Open)', ifelse(lw_section == 'u1800', ' (U1800)', '')), ', Season ', s)`"
---

<style type="text/css">

h1.title {
  font-size: 28px;
}
h1 { /* Header 1 */
  font-size: 10px;
}
h2 { /* Header 2 */
    font-size: 10px;
}
h3 { /* Header 3 */
  font-size: 24px; 
}

h4 { /* Header 4 */
  font-size: 18px; 
}

h1, h2, h3, h4 {
  text-align: center;
}

h1, .h1, h2, .h2, h3, .h3, h4, .h4 {
    margin-top: 84px;
}

</style>

<!-- h3: 18 -->

```{r, include = FALSE}
# Set default R chunk options for Rmd file
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# Load all required packages, incl. for functions
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, knitr, rio, kableExtra, gghighlight, data.table,
               ggrepel, ggridges, reactable, htmltools, httr, jsonlite, xml2, rvest, ndjson,
               reshape2, utf8, lubridate, tictoc, cowplot, sunburstR, d3r, webshot, plotly)  
```


```{r}
# Source supporting functions
source("C:/Users/rahul/Documents/Github/rahulan-c.github.io/lichess4545-stats/R/all_functions.R", local = knitr::knit_global())

# Load supporting lookup data

# 1. Gambit openings - to enable analysis of gambits and gambit-lovers
gambits <- read.csv("C:/Users/rahul/Documents/Github/rahulan-c.github.io/lichess4545-stats/data/lookup/gambits.csv")
# gambits <- read.csv("data/lookup/gambits.csv")

# 2. FIDE performance rating lookup values
# 2-column table with tournament performance scores and rating differences
# Compiled from https://handbook.fide.com/chapter/B022017
# Required for calculating player performance ratings using FIDE's method 
fide_tpr_lookup <- read.csv("C:/Users/rahul/Documents/Github/rahulan-c.github.io/lichess4545-stats/data/lookup/fide_tpr_lookup.csv")

# 3. Accounts banned from the Lichess4545 leagues
# Sourced from a local text file - last updated on 2021-07-12 from the original 4545 ban log
# All games involving banned players are removed before any stats are processed.
# banned <- read.csv("C:/Users/rahul/Documents/Github/4545-stats/data/players_booted_from_lichess4545.txt", header = F)
banned <- read.csv("C:/Users/rahul/Documents/Github/rahulan-c.github.io/lichess4545-stats/data/lookup/lichess4545_banned_players.csv")

```



```{r setup}
# Match user-defined document parameters to key variables, eg league, season, rounds, section etc.
league <- league
season <- s

# Get correct team_boards parameter
  if(league == "lonewolf"){team_boards <- 99} else
    if(season == 1){team_boards <- 4} else
      if(season == 2){team_boards <- 5} else
        if(season <= 15){team_boards <-  6} else 
          if(season <= 24){team_boards <-  8} else
            if(season <= 26){team_boards <-  10}

# Rounds
if(league == "team4545"){rounds <- c(seq(1:8))}
if(league == "lonewolf"){rounds <- c(seq(1:11))}

# LW U1800 choice
lw_u1800 <- ifelse(league == "lonewolf", ifelse(lw_section == "u1800", TRUE, FALSE), FALSE)

# Increment choice
increment <- ifelse(league == "lonewolf", 30, ifelse(league == "team4545", 45, NA))


# Set league-specific colours to use in plots
lw_col <- "#699486"        #1c401c (darkest), #225622 (med), #699486 (lightest)
lw_col_dark <- "#225622"
team_col <- "#557f97"      #245164 (darkest), #3c687d (med) #557f97 (lightest)
team_col_dark <- "#245164"
league_col <- ifelse(league == "lonewolf", lw_col, team_col)               
league_col_dark <- ifelse(league == "lonewolf", lw_col_dark, team_col_dark)

# Define custom default reactable theme for tables
options(reactable.theme = reactableTheme(
    borderColor = "#dfe2e5",
    stripedColor = "#f6f8fa",
    highlightColor = "#f0f5f9",
    cellPadding = "8px 12px",
    style = list(fontFamily = "-apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif"),
    searchInputStyle = list(width = "100%"),
    headerStyle = list(
      "&:hover[aria-sort]" = list(background = "hsl(0, 0%, 96%)"),
      "&[aria-sort='ascending'], &[aria-sort='descending']" = list(background = "hsl(0, 0%, 96%)"),
      borderColor = "#555"
    )
  )
)

```


```{r get_season_data, include = FALSE}
# Get data on season games, pairings and positions

league_load_label <- league
if(league == "lonewolf"){
  if(lw_u1800){league_load_label <- "lwu1800"} else {league_load_label <- "lwopen"}
}

# Load (tidied) games data
games <- readRDS(paste0("C:/Users/rahul/Documents/Github/rahulan-c.github.io/lichess4545-stats/data/games_", league_load_label, "_s", season, ".rds"))

# Load season pairings and positions data
pairings <- rio::import(paste0("C:/Users/rahul/Documents/Github/rahulan-c.github.io/lichess4545-stats/data/pairings_", league_load_label, "_s", season, ".csv"))
positions <- rio::import(paste0("C:/Users/rahul/Documents/Github/rahulan-c.github.io/lichess4545-stats/data/positions_", league_load_label, "_s", season, ".csv"))

# Final tidying of games data
# Add gambits data
games <- left_join(games, gambits, by = c("opening.name" = "gambit"))


# Fix all misprinted characters in character columns
games <- games %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã¼", "ü"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã¶", "ö"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã³", "ó"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã©", "é"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "â€¾", "‾"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "ãƒ„", "ツ")))

pairings <- pairings %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã¼", "ü"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã¶", "ö"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã³", "ó"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã©", "é"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "â€¾", "‾"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "ãƒ„", "ツ")))

positions <- positions %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã¼", "ü"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã¶", "ö"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã³", "ó"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã©", "é"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "â€¾", "‾"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "ãƒ„", "ツ")))


```


```{r exclude_cheaters}
# Remove all games and pairings featuring players banned from the leagues for cheating

# Get list of players to exclude from data
cheat_reasons <- c("Marked as using computer assistance on lichess",
                   "Cheating alt and marked as engine on lichess",
                   "Admitted to using assistance during a 4545 game",
                   "Cheating alt / Multi accounting in the league / LW",
                   "Violated terms of service on lichess",
                   "Violated Lichess terms of service")

cheats <- banned %>% 
  filter(Reason %in% cheat_reasons) %>% 
  filter(Other.Notes != "mark reversed and readmitted") %>% 
  pull(name)

games_incl_banned <- games
pairings_incl_banned <- pairings

# Exclude these players from the games data
games <- games %>% 
  filter(!(players.white.user.name %in% cheats)) %>% 
  filter(!(players.black.user.name %in% cheats)) %>% 
  filter(!(players.white.user.id %in% str_to_lower(cheats))) %>% 
  filter(!(players.black.user.id %in% str_to_lower(cheats)))

# Exclude from pairings data
pairings <- pairings %>% 
  filter(!(white %in% cheats)) %>% 
  filter(!(black %in% cheats)) %>% 
  filter(!(white %in% str_to_lower(cheats))) %>% 
  filter(!(black %in% str_to_lower(cheats)))

# # Test - just get games with banned players
# games_banned <- games %>% 
#   filter(white %in% banned | black %in% banned) %>% 
#   select(id, white, black, result)

```

### Overview


```{r season_dates}
# Get dates for first and last games
season_dates <- paste0(lubridate::day(min(games$started)), " ",
       lubridate::month(min(games$started), label = T), " ", 
       lubridate::year(max(games$started)),
       " to ",
       lubridate::day(max(games$started)), " ",
       lubridate::month(max(games$started), label = T), " ",
       lubridate::year(max(games$started)))

# Number of forfeited/unplayed games
forfeits <- pairings_incl_banned %>% 
  filter(winner == "forfeit/unplayed") %>% 
  nrow()

# White wins, draws and Black wins
wdl <- games %>% 
  group_by(result) %>% 
  tally() %>%
  mutate(perc = n/nrow(games))

games_w <- wdl %>% filter(result == "1-0") %>% pull(n)
perc_w <- wdl %>% filter(result == "1-0") %>% pull(perc)
games_b <- wdl %>% filter(result == "0-1") %>% pull(n)
perc_b <- wdl %>% filter(result == "0-1") %>% pull(perc)
games_d <- wdl %>% filter(result == "1/2-1/2") %>% pull(n)
perc_d <- wdl %>% filter(result == "1/2-1/2") %>% pull(perc)

# How games ended
ended <- games %>% 
  group_by(status) %>% 
  tally() %>% 
  mutate(status = replace(status, status == "outoftime", "out of time")) %>%
  mutate(status = replace(status, status == "stalemate", "stalemate")) %>%
  arrange(desc(n))

```

- The season ran from `r season_dates`.
- `r formatC(length(unique(c(unique(games$white), unique(games$black)))), big.mark = ",")` players took part, playing `r formatC(nrow(games), big.mark = ",")` games in total. `r formatC(forfeits, big.mark = ",")` games were either forfeited or set as scheduling draws.
- Across the season, White won `r formatC(games_w, big.mark=",")` games (`r round(perc_w*100, 1)`%), `r formatC(games_d, big.mark=",")` games (`r round(perc_d*100, 1)`%) were drawn, and Black won `r formatC(games_b, big.mark=",")` games (`r round(perc_b*100, 1)`%).
- `r formatC(ended$n[ended$status == "resign"], big.mark=",")` games ended with a resignation, `r formatC(ended$n[ended$status == "mate"], big.mark=",")` games by checkmate, `r formatC(ended$n[ended$status == "out of time"], big.mark=",")` games by time running out, and `r formatC(ended$n[ended$status == "stalemate"], big.mark=",")` games by stalemate.

### Standings

```{r}
standings_url <- paste0("https://www.lichess4545.com/",
                        league, "/season/",
                        season, "/standings/")
```


Link: `r standings_url`

#### Final podium

```{r, eval = ifelse(league == "team4545", TRUE, FALSE)}
# Produce table of all players for the top 3 teams in the final standings

# Identify top 3 teams
top_3 <- positions %>% 
  filter(round == max(positions$round)) %>% 
  filter(rank %in% c(1:3))

# Identify everyone who played for the top 3 teams
players_teams <- rbind(tibble("player" = games$white, "team" = games$team_w, "round" = games$round),
                       tibble("player" = games$black, "team" = games$team_b, "round" = games$round)) %>% 
  group_by(player, team) %>% 
  summarise(games = n()) %>% 
  arrange(desc(games))

players_gold <- players_teams %>% filter(team == top_3$team[top_3$rank == 1]) %>% arrange(desc(games)) %>% pull(player)
players_silver <- players_teams %>% filter(team == top_3$team[top_3$rank == 2]) %>% arrange(desc(games)) %>% pull(player)
players_bronze <- players_teams %>% filter(team == top_3$team[top_3$rank == 3]) %>% arrange(desc(games)) %>% pull(player)

# Identify length of longest team list
longest_team <- max(c(length(players_gold), 
                      length(players_silver), 
                      length(players_bronze)))

if(length(players_gold) < longest_team){
  players_gold <- c(players_gold, rep("", longest_team - length(players_gold)))
}

if(length(players_silver) < longest_team){
  players_silver <- c(players_silver, rep("", longest_team - length(players_silver)))
}

if(length(players_bronze) < longest_team){
  players_bronze <- c(players_bronze, rep("", longest_team - length(players_bronze)))
}

# Create final table of players
winners <- tibble("Gold" = c(top_3$team[top_3$rank == 1], players_gold),
                  "Silver" = c(top_3$team[top_3$rank == 2], players_silver),
                  "Bronze" = c(top_3$team[top_3$rank == 3], players_bronze))

# Show final players data as reactable table
reactable(winners,
          fullWidth = TRUE,
          resizable = TRUE,
          compact = TRUE,
          pagination = FALSE,
          columns = list(
            Gold = colDef(name = "1st place", align = "center", minWidth = 250),
            Silver = colDef(name = "2nd place", align = "center", minWidth = 250),
            Bronze = colDef(name = "3rd place", align = "center", minWidth = 250)),
          rowStyle = function(index) {
            if (index == 1) {
              list(background = "rgba(0, 0, 0, 0.05)")
            }
          })
```



#### Story of the season

```{r position_tracker, out.width="75%"}
# Team/player position tracker

if(league == "team4545"){
  
top_places <- positions %>% 
  filter(round == 8) %>% 
  arrange(rank) %>% 
  filter(rank <= 3) %>% 
  pull(team)
  
position_tracker <- positions %>% 
  mutate(round = as.factor(round)) %>% 
  ggplot(aes(x = round, y = rank, colour = team)) +
  geom_line(aes(group = team), size = 2) +
  # geom_point(aes(group = team), size = 2) +
  theme_minimal() +
  # scale_y_reverse(limits = c(20, 1), breaks = integer_breaks()) +
  scale_y_reverse(limits = c(max(positions$rank), 1), breaks = c(max(positions$rank), 1)) +
  scale_x_discrete(expand = expansion(add = c(0.5, 0.5))) +
  gghighlight::gghighlight(team %in% top_places, use_direct_label = T,
                             unhighlighted_params = list(colour = alpha("grey", 0.1)),
                             label_params = list(size = 4, 
                                                 nudge_x = -1, 
                                                 nudge_y = -15, 
                                                 direction = "y")) +
  labs(x = "Round",
       y = "Rank after each round") +
  theme(legend.position = "right") +
  scale_color_manual(values = c("#ffd700", "#c0c0c0", "#cd7f32"),
                       breaks = c(top_places),
                       labels = c(top_places))

position_tracker

}

if(league == "lonewolf"){
  
  top_places <- positions %>% 
    filter(round == 12) %>% 
    arrange(pos) %>% 
    filter(pos <= 3) %>%  
    pull(player)
  
  position_tracker <- positions %>% 
    filter(!(is.na(pos))) %>% 
    mutate(player = str_to_lower(player)) %>% 
    mutate(round = as.factor(round)) %>% 
    ggplot(aes(x = round, y = pos, colour = player)) +
    geom_line(aes(group = player), size = 2) +
    # geom_point(aes(group = player), size = 2) +
    theme_minimal() +
    scale_y_reverse(limits = c(50, 1), breaks = integer_breaks()) +
    scale_x_discrete(expand = expansion(add = c(0, 2))) +
    gghighlight::gghighlight(player %in% top_places, use_direct_label = T,
                             unhighlighted_params = list(colour = alpha("grey", 0.1)),
                             label_params = list(size = 4, nudge_x = 2, nudge_y = 0, direction = "y")) +
    labs(x = "Round",
         y = "Rank before round") +
    theme(legend.position = "right") +
    scale_color_manual(values = c("#ffd700", "#c0c0c0", "#cd7f32"),
                       breaks = c(top_places),
                       labels = c(top_places))

  position_tracker

}



```


#### Top performers by board

*Only shown for 4545 stats*

```{r bperfs, eval = ifelse(league == "team4545", TRUE, FALSE)}
# Board perf ratings


bperfs_w <- pairings %>% 
  filter(winner != "forfeit/unplayed") %>% 
  group_by(white, board) %>%
  summarise(sum_opp_rating = sum(rating_b),
            games = n(),
            points = ((sum(winner == "white") * 1) + (sum(winner == "draw") * 0.5)),
            wins = sum(winner == "white"),
            draws = sum(winner == "draw"),
            losses = sum(winner == "black"),
            initial_rating = rating_w[which.min(round)],
            initial_round = min(round)) %>% 
  rename("player" = white)

bperfs_b <- pairings %>% 
  filter(winner != "forfeit/unplayed") %>% 
  group_by(black, board) %>%
  summarise(sum_opp_rating = sum(rating_w),
            games = n(),
            points = ((sum(winner == "black") * 1) + (sum(winner == "draw") * 0.5)),
            wins = sum(winner == "black"),
            draws = sum(winner == "draw"),
            losses = sum(winner == "white"),
            initial_rating = rating_b[which.min(round)],
            initial_round = min(round)) %>% 
  rename("player" = black)

bperfs <- rbind(bperfs_w, bperfs_b)
rm(bperfs_w, bperfs_b)

# Compute board performance ratings using FIDE method
# Create list with board-specific rankings
bperfs <- bperfs %>% 
  group_by(player, board) %>% 
  summarise(sum_opp_rating = sum(sum_opp_rating),
            games = sum(games),
            avg_opp_rating = sum_opp_rating / games,
            points = sum(points),
            tp_score = points / games,
            wins = sum(wins),
            draws = sum(draws),
            losses = sum(losses),
            initial_rating = initial_rating[which.min(initial_round)]) %>%
  mutate(adj = fide_tpr_lookup[match(round(tp_score, 2), fide_tpr_lookup$p),2]) %>% 
  mutate(bperf_rating = avg_opp_rating + adj) %>% 
  mutate(bperf_diff = bperf_rating - initial_rating) %>% 
  filter(games >= 4) %>%
  ungroup() %>% 
  group_by(board) %>% 
  arrange(desc(bperf_rating)) %>% 
  slice_max(order_by = bperf_rating, n = 5) %>% 
  select(board, player, games, points, bperf_rating)

# Show board rankings in a table
tbl_bperfs <- reactable(bperfs, groupBy = "board",
          fullWidth = FALSE,
          resizable = TRUE,
          compact = T,
          columns = list(
            board = colDef(name = "Board",
                          align = "center",
                          minWidth = 100),
            player = colDef(name = "Player",
                           minWidth = 175),
            games = colDef(name = "Games", minWidth = 75),
            points = colDef(name = "Points", minWidth =  75),
            bperf_rating = colDef(name = "Board Perf.", minWidth = 100,
                                  format = colFormat(digits = 0))
          )
          )
tbl_bperfs

```


### Summary charts {.tabset}

#### Match results (4545 only)



```{r, out.width = "75%", eval = ifelse(league == "team4545", TRUE, FALSE)}
# Plot distribution of match results
games %>% 
  select(match, team_w, team_b, gp_w, gp_b) %>% 
  mutate(gp_1 = pmax(gp_w, gp_b),
         gp_2 = pmin(gp_w, gp_b),
         team_1 = pmin(team_w, team_b),
         team_2 = pmax(team_w, team_b),
         match = paste0(team_1, " vs ", team_2)) %>%
  distinct(match, .keep_all = T) %>% 
  select(gp_1, gp_2) %>% 
  mutate(margin = gp_1 - gp_2) %>% 
  group_by(margin) %>% 
  summarise(games = n()) %>% 
  arrange(desc(margin)) %>% 
  ggplot(aes(margin, games)) +
  geom_col() +
  theme_cowplot() +
  labs(x = "Winning margin (game points)",
       y = "Matches") +
  scale_x_continuous(breaks = integer_breaks())
```


#### When were games played?

```{r games_by_day, fig.show="hold", out.width = "50%"}

# Create summary table with info for heatmap
games_by_day_time <- plyr::ddply(games, c("hour", "wday"),
                             summarise,
                             N = length(started))
# Reverse order of months
games_by_day_time$wday <- factor(games_by_day_time$wday, levels=rev(levels(games_by_day_time$wday)))

# Make bar chart of games per day
plt_gamesbyday <- games_by_day_time %>% 
  group_by(wday) %>% 
  tally(N) %>% 
  mutate(wday = fct_relevel(wday, 
                            "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")) %>% 
  ggplot(aes(wday, n)) +
  geom_col(fill = league_col, colour = league_col) +
  geom_text(aes(label = n), colour = "white", size = 5, vjust = 1.5) +
  theme_minimal() +
  labs(x = "Day", y = "Games", 
       subtitle = paste0(round((sum(games_by_day_time[games_by_day_time$wday %in% c("Sat", "Sun"), ]$N) / nrow(games)) * 100, 0),
                         "% played on weekend")) +
  scale_y_continuous(breaks = integer_breaks()) +
  theme(axis.text.x = element_text(size = 12)) +
  theme(plot.title = element_text(size = 10, hjust = 0.5)) +
  theme(plot.subtitle = element_text(size = 10))
plt_gamesbyday

# Make heatmap
heat_dayhour <- ggplot(games_by_day_time, aes(hour, wday)) + geom_tile(aes(fill = N),colour = "white", na.rm = TRUE) +
  scale_fill_gradient(low = "white", high = league_col) +
  guides(fill=guide_legend(title="# games")) +
  theme_bw() + theme_minimal() +
  labs(x = "Hour (UTC)", y = "Day") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
heat_dayhour

```

#### How long did games take?

```{r hists, fig.show="hold", out.width = "50%"}
# Number of moves histogram
moves_hist <- games %>% 
  ggplot(aes(num_moves)) +
  geom_histogram(binwidth = 5, fill = league_col, col = "white") +
  theme_minimal() +
  geom_vline(xintercept = mean(games$num_moves), size = 1, colour="#333333", linetype = "dashed") +
  scale_y_continuous(breaks = integer_breaks()) +
  labs(subtitle = paste0("Average moves/game: ", round(mean(games$num_moves), 1)),
       x = "# moves", y = "Games")

# Game duration histogram
duration_hist <- games %>% 
  ggplot(aes(duration/60)) +
  geom_histogram(binwidth = 15, fill = league_col, col = "white") +
  theme_minimal() +
  geom_vline(xintercept = mean(games$duration/60), size = 1, colour="#333333", linetype = "dashed") +
  labs(x = "Minutes", y = "Games",
       subtitle = paste0("Average time taken/game: ", round(mean(games$duration/60), 1), " minutes")) +
  scale_y_continuous(breaks = integer_breaks())

moves_hist
duration_hist
```


### Longest games {.tabset}

#### By moves

*Includes games ranked at or above the 90th percentile by number of moves.*

```{r longest_moves}
# Longest games (by # moves)

longest_moves <- games %>% 
  arrange(desc(num_moves)) %>% 
  select("white" = players.white.user.name, 
         "black" = players.black.user.name, 
         id, 
         num_moves,
         started) %>% 
  mutate(players = paste0(white, " - ", black),
         url = paste0("https://lichess.org/", id),
         rank = seq(1:nrow(.))) %>% 
  select(rank, players, started, url, num_moves) %>% 
  mutate(date = sprintf('%s %2d %2s %2d', lubridate::wday(started, label=T, abbr=T), lubridate::day(started), lubridate::month(started, label = T, abbr = T), lubridate::year(started))) %>% 
  mutate(prank = ntile(num_moves, 100)) %>% # calculate percentiles
  filter(prank >= 90) %>%  # only show games above 75th percentile
  select(-c(prank, started)) %>% 
  select(rank, players, date, url, num_moves)

reactable(longest_moves,
          pagination = TRUE,
          searchable = TRUE,
          fullWidth = FALSE,
          resizable = TRUE,
          compact = T,
          columns = list(
            rank = colDef(name = "Rank",
                          align = "center",
                          minWidth = 50),
          players = colDef(name = "Players / Link",
                           minWidth = 300,
                           html = TRUE, 
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', longest_moves$url[index], value)
          }),
          date = colDef(name = "Date",
                        minWidth = 140),
          url = colDef(name = "URL",
                       show = FALSE),
          num_moves = colDef(name = "Moves",
                                  minWidth = 100)
          )
          )



```

#### By total time

*Includes games ranked at or above the 90th percentile by total time.*

```{r longest_time}
# Longest games (by duration)
# only show top 25%
# cols: rank, players (w/ url), date, time taken

longest_duration <- games %>% 
  arrange(desc(duration)) %>% 
  select("white" = players.white.user.name, 
         "black" = players.black.user.name, 
         id, 
         duration,
         started) %>% 
  mutate(players = paste0(white, " - ", black),
         url = paste0("https://lichess.org/", id),
         rank = seq(1:nrow(.))) %>% 
  select(rank, players, started, url, duration) %>% 
  mutate(duration = lubridate::seconds_to_period(duration)) %>%
  mutate(duration_print = sprintf('%2gh %2gm %2gs', lubridate::hour(duration), lubridate::minute(duration), lubridate::second(duration))) %>% # more readable total times
  mutate(date = sprintf('%s %2d %2s %2d', lubridate::wday(started, label=T, abbr=T), lubridate::day(started), lubridate::month(started, label = T, abbr = T), lubridate::year(started))) %>% 
  mutate(prank = ntile(duration, 100)) %>% # calculate percentiles
  filter(prank >= 90) %>%  # only show games above certain percentile
  select(rank, players, date, url, duration_print)

reactable(longest_duration,
          pagination = TRUE,
          searchable = TRUE,
          fullWidth = FALSE,
          resizable = TRUE,
          compact = T,
          columns = list(
            rank = colDef(name = "Rank",
                          align = "center",
                          minWidth = 50),
          players = colDef(name = "Players / Link",
                           minWidth = 300,
                           html = TRUE, 
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', longest_duration$url[index], value)
          }),
          date = colDef(name = "Date",
                        minWidth = 140),
          url = colDef(name = "URL",
                       show = FALSE),
          duration_print = colDef(name = "Total time",
                                  minWidth = 100)
          )
          )

```

### Stats by board / rating band {.tabset}

#### ACPLs / blunder rates

```{r wins_by_col_by_board, fig.show="hold", out.width = "50%", eval = ifelse(league == "team4545", TRUE, FALSE)}
# Plot wins by colour by board
# Plot ACPL by board

wins_by_colour_board <- games %>% 
    select(board, result) %>% 
    add_count(board, name = "n_board") %>% 
    add_count(board, result, name = "n_board_result") %>% 
    mutate(perc = n_board_result / n_board) %>% 
    distinct() %>% 
  mutate(cat = case_when(
    result == "1-0" ~ "cat1",
    result == "1/2-1/2" ~ "cat2",
    result == "0-1" ~ "cat3",
    TRUE ~ NA_character_
  )) %>%
  group_by(board) %>% 
  arrange(desc(cat)) %>% 
  # Get the % labels positioned right
  mutate(pos_label = ifelse(cat == "cat3",
                            # White wins
                            perc / 2, 
                            ifelse(cat == "cat2",
                                   # Draws
                                   lag(perc) + (perc/2), 
                                   ifelse(cat == "cat1",
                                          # Black wins
                                          lag(perc, 2) + lag(perc) + (perc/2), 
                                          0)))) %>% 
  ungroup()
  
  plt_wins_board <- ggplot(wins_by_colour_board, aes(x = board, y = n_board_result, fill = cat)) +
    geom_bar(stat = "identity", position = "fill", colour = "#ffffff") +
    theme_cowplot() +
    scale_x_continuous(trans = "reverse", 
                       labels = paste0("B",as.character(wins_by_colour_board$board)), 
                       breaks = wins_by_colour_board$board) +
    scale_y_continuous(trans = "reverse", labels = scales::percent, breaks = waiver()) +
    geom_text(aes(y = pos_label, label = paste0(round(perc*100, 0), "%")), colour = "white") +
    labs(x = "", y = "") +
    theme(legend.justification = "centre",
          legend.position = "bottom",
          legend.title = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          axis.ticks.y = element_blank(),
          axis.line.x = element_blank(),
          axis.line.y = element_blank()) +
    scale_fill_manual(values = c("#b5b5b5", "#6c6c6c", "#383838"), 
                      labels = c("1-0", "1/2-1/2", "0-1")) +
    coord_flip()
  
# c("#383838", "#6c6c6c", "#b5b5b5")
plt_wins_board

# Compute errors by board
error_rates_w <- games %>% 
  select(white, board, num_moves, 
         players.white.analysis.blunder, players.white.analysis.mistake, players.white.analysis.inaccuracy, players.white.analysis.acpl,
         players.black.analysis.blunder, players.black.analysis.mistake, players.black.analysis.inaccuracy, players.black.analysis.acpl)

error_rates_b <- games %>% 
  select(black, board, num_moves, 
         players.black.analysis.blunder, players.black.analysis.mistake, players.black.analysis.inaccuracy, players.black.analysis.acpl,
         players.white.analysis.blunder, players.white.analysis.mistake, players.white.analysis.inaccuracy, players.white.analysis.acpl)

colnames(error_rates_w) <- c("player", "board", "moves", "blunders", "mistakes", "inaccuracies", "acpl",
                             "opp_blunders", "opp_mistakes", "opp_inaccuracies", "opp_acpl")
colnames(error_rates_b) <- c("player", "board", "moves", "blunders", "mistakes", "inaccuracies", "acpl",
                             "opp_blunders", "opp_mistakes", "opp_inaccuracies", "opp_acpl")

error_rates <- rbind(error_rates_w, error_rates_b)
rm(error_rates_w, error_rates_b)

error_rates <- error_rates %>% 
  mutate(cpl = acpl * moves,
         opp_cpl = opp_acpl * moves)

error_rates_grouped <- error_rates %>% 
  group_by(board) %>% 
  summarise(games = n(),
            blunder_rate = sum(blunders, na.rm = T) / sum(moves, na.rm = T),
            mistake_rate = sum(mistakes, na.rm = T) / sum(moves, na.rm = T),
            inaccuracy_rate = sum(inaccuracies, na.rm = T) / sum(moves, na.rm = T),
            error_rate = blunder_rate + mistake_rate + inaccuracy_rate,
            acpl = sum(cpl, na.rm = T) / sum(moves, na.rm = T)) %>% 
  mutate(blunder_rate = round(blunder_rate * 100, 1),
         error_rate = round(error_rate * 100, 1),
         acpl = round(acpl, 1)) %>% 
  select(board, games, acpl, blunder_rate) %>% 
  arrange(board)

# Plot ACPL by board
plot_acpl_by_board <- ggplot(error_rates_grouped, aes(x = board, y = acpl)) +
  geom_line(col = "darkblue") +
  geom_point(col = "darkblue") +
  geom_text_repel(label = error_rates_grouped$acpl, col = "darkblue") +
  theme_minimal() +
  scale_x_continuous(labels = paste0("B",as.character(error_rates_grouped$board)), 
                     breaks = error_rates_grouped$board) +
  labs(x = "Board", y = "ACPL",
       title = "ACPL by board") +
  theme_cowplot()

plot_acpl_by_board
```


```{r error_rates_by_rating_band, eval = ifelse(league == "team4545", FALSE, TRUE)}
# Calculate error rates for summary stats

# Plot errors by rating band
error_rates_w <- games %>% 
  select(white, rating_w, num_moves, 
         players.white.analysis.blunder, players.white.analysis.mistake, players.white.analysis.inaccuracy, players.white.analysis.acpl,
         players.black.analysis.blunder, players.black.analysis.mistake, players.black.analysis.inaccuracy, players.black.analysis.acpl)

error_rates_b <- games %>% 
  select(black, rating_b, num_moves, 
         players.black.analysis.blunder, players.black.analysis.mistake, players.black.analysis.inaccuracy, players.black.analysis.acpl,
         players.white.analysis.blunder, players.white.analysis.mistake, players.white.analysis.inaccuracy, players.white.analysis.acpl)

colnames(error_rates_w) <- c("player", "rating", "moves", "blunders", "mistakes", "inaccuracies", "acpl",
                             "opp_blunders", "opp_mistakes", "opp_inaccuracies", "opp_acpl")
colnames(error_rates_b) <- c("player", "rating", "moves", "blunders", "mistakes", "inaccuracies", "acpl",
                             "opp_blunders", "opp_mistakes", "opp_inaccuracies", "opp_acpl")

error_rates <- rbind(error_rates_w, error_rates_b)
rm(error_rates_w, error_rates_b)

error_rates <- error_rates %>% 
  mutate(cpl = acpl * moves,
         opp_cpl = opp_acpl * moves)

error_rates$rating_group <- cut(error_rates$rating, 
                                breaks=c(800, 1000, 1200, 1400, 1600, 1800, 2000,
                                         2200, 2400, 2600),
                                labels = c("800-1000", "1000-1200",
                                           "1200-1400", "1400-1600", "1600-1800",
                                           "1800-2000", "2000-2200",
                                           "2200-2400", "2400-2600"),
                                include.lowest=TRUE, dig.lab = 4)

error_rates_grouped <- error_rates %>% 
  group_by(rating_group) %>% 
  summarise(games = n(),
            blunder_rate = sum(blunders, na.rm = T) / sum(moves, na.rm = T),
            mistake_rate = sum(mistakes, na.rm = T) / sum(moves, na.rm = T),
            inaccuracy_rate = sum(inaccuracies, na.rm = T) / sum(moves, na.rm = T),
            error_rate = blunder_rate + mistake_rate + inaccuracy_rate,
            acpl = sum(cpl, na.rm = T) / sum(moves, na.rm = T)) %>% 
  mutate(blunder_rate = round(blunder_rate * 100, 1),
         error_rate = round(error_rate * 100, 1),
         acpl = round(acpl, 1)) %>% 
  select(rating_group, games, blunder_rate, error_rate, acpl) %>% 
  arrange(desc(rating_group))

error_rates_grouped %>% 
  kable(caption = "Error rates by rating band",
        col.names = c("Rating band", "Games","Blunder rate", "Total error rate", "ACPL")) %>% 
  kableExtra::kable_classic(full_width = F, html_font = "arial", position = "left")


```



#### Games with lowest combined ACPL

The games with the lowest combined ACPL (including draws).


```{r lowest_acpl_games}

if(league == "team4545"){
# Show games with lowest combined ACPL by board
lowest_acpl_games_all <- games %>% 
  filter(!(is.na(board))) %>% 
  select(id, board, white, black, players.white.analysis.acpl, players.black.analysis.acpl, result, started) %>% 
  mutate(sum_acpl = players.white.analysis.acpl + players.black.analysis.acpl,
         url = paste0("https://lichess.org/", id),
         players = paste0(white, " - ", black)) %>%
  mutate(date = sprintf('%s %2d %2s %2d', lubridate::wday(started, label=T, abbr=T), lubridate::day(started), lubridate::month(started, label = T, abbr = T), lubridate::year(started))) %>% 
  select(board, players, url, result, sum_acpl, date) %>% 
  group_by(board) %>% 
  slice_min(sum_acpl) 

reactable(lowest_acpl_games_all,
          pagination = FALSE,
          searchable = FALSE,
          fullWidth = FALSE,
          resizable = TRUE,
          compact = T,
          columns = list(
          board = colDef(name = "Board", align = "center", minWidth = 70),
          date = colDef(name = "Date", minWidth = 140),
          players = colDef(name = "Players / Link",
                           minWidth = 250,
                           html = TRUE,
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', lowest_acpl_games_all$url[index], value)
          }),
          url = colDef(show = FALSE),
          result = colDef(name = "Result", align = "center"),
          sum_acpl = colDef(name = "Sum ACPL", align = "center")
          )
)
}

if(league == "lonewolf"){
# Show games with lowest combined ACPL by board
lowest_acpl_games_all <- games %>% 
  select(id, white, black, players.white.analysis.acpl, players.black.analysis.acpl, result, started) %>% 
  mutate(sum_acpl = players.white.analysis.acpl + players.black.analysis.acpl,
         url = paste0("https://lichess.org/", id),
         players = paste0(white, " - ", black)) %>%
  mutate(date = sprintf('%s %2d %2s %2d', lubridate::wday(started, label=T, abbr=T), lubridate::day(started), lubridate::month(started, label = T, abbr = T), lubridate::year(started))) %>% 
  select(players, url, result, sum_acpl, date) %>% 
  slice_min(sum_acpl, n = 10) %>% 
  arrange(sum_acpl)

reactable(lowest_acpl_games_all,
          pagination = FALSE,
          searchable = FALSE,
          fullWidth = FALSE,
          resizable = TRUE,
          compact = T,
          columns = list(
          date = colDef(name = "Date", minWidth = 140),
          players = colDef(name = "Players / Link",
                           minWidth = 250,
                           html = TRUE,
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', lowest_acpl_games_all$url[index], value)
          }),
          url = colDef(show = FALSE),
          result = colDef(name = "Result", align = "center"),
          sum_acpl = colDef(name = "Sum ACPL", align = "center")
          )
)
}


```

#### Excl. draws

The *decisive* games with the lowest combined ACPL.

```{r}
# Show same but for decisive games

if(league == "team4545"){
lowest_acpl_games_decisive <- games %>% 
  filter(!(is.na(board))) %>% 
  filter(winner %in% c("white", "black")) %>% 
  select(id, board, white, black, players.white.analysis.acpl, players.black.analysis.acpl, result, started) %>% 
  mutate(sum_acpl = players.white.analysis.acpl + players.black.analysis.acpl,
         url = paste0("https://lichess.org/", id),
         players = paste0(white, " - ", black)) %>%
  mutate(date = sprintf('%s %2d %2s %2d', lubridate::wday(started, label=T, abbr=T), lubridate::day(started), lubridate::month(started, label = T, abbr = T), lubridate::year(started))) %>% 
  select(board, players, url, result, sum_acpl, date) %>% 
  group_by(board) %>% 
  slice_min(sum_acpl) 

reactable(lowest_acpl_games_decisive,
          pagination = FALSE,
          searchable = FALSE,
          fullWidth = FALSE,
          resizable = TRUE,
          compact = T,
          columns = list(
          board = colDef(name = "Board", align = "center", minWidth = 70),
          date = colDef(name = "Date", minWidth = 140),
          players = colDef(name = "Players / Link",
                           minWidth = 250,
                           html = TRUE,
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', lowest_acpl_games_decisive$url[index], value)
          }),
          url = colDef(show = FALSE),
          result = colDef(name = "Result", align = "center"),
          sum_acpl = colDef(name = "Sum ACPL", align = "center")
          ))
}

if(league == "lonewolf"){
lowest_acpl_games_decisive <- games %>% 
  filter(winner %in% c("white", "black")) %>% 
  select(id, white, black, players.white.analysis.acpl, players.black.analysis.acpl, result, started) %>% 
  mutate(sum_acpl = players.white.analysis.acpl + players.black.analysis.acpl,
         url = paste0("https://lichess.org/", id),
         players = paste0(white, " - ", black)) %>%
  mutate(date = sprintf('%s %2d %2s %2d', lubridate::wday(started, label=T, abbr=T), lubridate::day(started), lubridate::month(started, label = T, abbr = T), lubridate::year(started))) %>% 
  select(players, url, result, sum_acpl, date) %>% 
  slice_min(sum_acpl, n = 10) %>% 
  arrange(sum_acpl)

reactable(lowest_acpl_games_decisive,
          pagination = FALSE,
          searchable = FALSE,
          fullWidth = FALSE,
          resizable = TRUE,
          compact = T,
          columns = list(
          date = colDef(name = "Date", minWidth = 140),
          players = colDef(name = "Players / Link",
                           minWidth = 250,
                           html = TRUE,
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', lowest_acpl_games_decisive$url[index], value)
          }),
          url = colDef(show = FALSE),
          result = colDef(name = "Result", align = "center"),
          sum_acpl = colDef(name = "Sum ACPL", align = "center")
          ))
}

```

### Openings {.tabset}



#### Popular openings

All openings played in the season, excluding variations.

```{r}
# Show openings by broad opening name (excl. variation)
openings_exclvar <- games %>% 
  group_by(opening.broad) %>% 
  summarise(games = n(),
            mean_rating = mean(mean_rating),
            score_w = sum(score_w),
            white_wins = (sum(result == "1-0") / games) * 100,
            draws = (sum(result == "1/2-1/2") / games) * 100,
            black_wins = (sum(result == "0-1") / games) * 100,
            mean_eval_after_15 = mean(eval_after_15, na.rm = T) / 100) %>% 
  arrange(desc(games)) %>% 
  mutate(rank = seq(1:nrow(.)),
         perc_w = (score_w / games) * 100) %>%
  select(rank, opening.broad, games, perc_w, white_wins, draws, black_wins, 
         mean_eval_after_15, mean_rating)

reactable(openings_exclvar,
          pagination = TRUE, 
          fullWidth = TRUE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center"),
    opening.broad = colDef(name = "Opening", minWidth = 200),
    games = colDef(name = "Games"),
    perc_w = colDef(name = "White's score (%)", format = colFormat(digits = 0)),
    white_wins = colDef(name = "White wins (%)", format = colFormat(digits = 0)),
    draws = colDef(name = "Draws (%)", format = colFormat(digits = 0)),
    black_wins = colDef(name = "Black wins (%)", format = colFormat(digits = 0)),
    mean_eval_after_15 = colDef(name = "Mean eval after 15 moves", format = colFormat(digits = 2)),
    mean_rating = colDef(name = "Avg rating", format = colFormat(digits = 0))),
    compact = T)
```


#### Popular variations

All openings played in the season, including variations.

```{r}
# Show openings by Lichess-determined opening name including variation
openings_inclvar <- games %>% 
  group_by(opening.name) %>% 
  summarise(games = n(),
            mean_rating = mean(mean_rating),
            score_w = sum(score_w),
            white_wins = (sum(result == "1-0") / games) * 100,
            draws = (sum(result == "1/2-1/2") / games) * 100,
            black_wins = (sum(result == "0-1") / games) * 100,
            mean_eval_after_15 = mean(eval_after_15, na.rm = T) / 100) %>% 
  arrange(desc(games)) %>% 
  mutate(rank = seq(1:nrow(.)),
         perc_w = (score_w / games)*100) %>%
  select(rank, opening.name, games, perc_w, white_wins, draws, black_wins, 
         mean_eval_after_15, mean_rating)

reactable(openings_inclvar,
          pagination = TRUE, 
          fullWidth = TRUE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center", footer = "Total"),
    opening.name = colDef(name = "Opening", minWidth = 300),
    games = colDef(name = "Games"),
    perc_w = colDef(name = "White's score (%)", format = colFormat(digits = 0)),
    white_wins = colDef(name = "White wins (%)", format = colFormat(digits = 0)),
    draws = colDef(name = "Draws (%)", format = colFormat(digits = 0)),
    black_wins = colDef(name = "Black wins (%)", format = colFormat(digits = 0)),
    mean_eval_after_15 = colDef(name = "Mean eval after 15 moves", format = colFormat(digits = 2)),
    mean_rating = colDef(name = "Avg rating", 
                         format = colFormat(digits = 0))),
    defaultColDef = colDef(footerStyle = list(fontWeight = "bold")),
    compact = T)
```



#### Best for White

The best-scoring main openings for White. 

*Includes all main openings played in at least 10 games.* 

```{r}
# Same as (3) but ordered by White score instead
openings_bestwhite <- games %>% 
  group_by(opening.broad) %>% 
  summarise(games = n(),
            mean_rating = mean(mean_rating),
            score_w = sum(score_w),
            white_wins = (sum(result == "1-0") / games) * 100,
            draws = (sum(result == "1/2-1/2") / games) * 100,
            black_wins = (sum(result == "0-1") / games) * 100,
            mean_eval_after_15 = mean(eval_after_15, na.rm = T) / 100) %>% 
  mutate(perc_w = (score_w / games) * 100) %>%
  arrange(desc(perc_w)) %>% 
  filter(games > 10) %>% 
  mutate(rank = seq(1:nrow(.))) %>% 
  select(rank, opening.broad, games, perc_w, white_wins, draws, black_wins,
         mean_eval_after_15, mean_rating)

reactable(openings_bestwhite,
          pagination = TRUE, 
          fullWidth = TRUE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center"),
    opening.broad = colDef(name = "Opening", minWidth = 200),
    games = colDef(name = "Games"),
    perc_w = colDef(name = "White's score (%)", format = colFormat(digits = 0)),
    white_wins = colDef(name = "White wins (%)", format = colFormat(digits = 0)),
    draws = colDef(name = "Draws (%)", format = colFormat(digits = 0)),
    black_wins = colDef(name = "Black wins (%)", format = colFormat(digits = 0)),
    mean_eval_after_15 = colDef(name = "Mean eval after 15 moves", format = colFormat(digits = 2)),
    mean_rating = colDef(name = "Avg rating", format = colFormat(digits = 0))),
    compact = T)

```

#### Best for Black

The best-scoring main openings for Black. 

*Includes all main openings played in at least 10 games.* 

```{r openings_for_black}
# Same ordered by Black score
openings_bestblack <- games %>% 
  group_by(opening.broad) %>% 
  summarise(games = n(),
            mean_rating = mean(mean_rating),
            score_b = sum(score_b),
            white_wins = (sum(result == "1-0") / games) * 100,
            draws = (sum(result == "1/2-1/2") / games) * 100,
            black_wins = (sum(result == "0-1") / games) * 100,
            mean_eval_after_15 = mean(eval_after_15, na.rm = T) / 100) %>% 
  mutate(perc_b = (score_b / games)*100) %>% 
  arrange(desc(perc_b)) %>% 
  filter(games > 10) %>% 
  mutate(rank = seq(1:nrow(.))) %>%
  select(rank, opening.broad, games, perc_b, black_wins, draws, white_wins, 
         mean_eval_after_15, mean_rating)

reactable(openings_bestblack,
          pagination = TRUE, 
          fullWidth = TRUE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center"),
    opening.broad = colDef(name = "Opening", minWidth = 200),
    games = colDef(name = "Games"),
    perc_b = colDef(name = "Black's score (%)", format = colFormat(digits = 0)),
    white_wins = colDef(name = "White wins (%)", format = colFormat(digits = 0)),
    draws = colDef(name = "Draws (%)", format = colFormat(digits = 0)),
    black_wins = colDef(name = "Black wins (%)", format = colFormat(digits = 0)),
    mean_eval_after_15 = colDef(name = "Mean eval after 15 moves", format = colFormat(digits = 2)),
    mean_rating = colDef(name = "Avg rating", format = colFormat(digits = 0))),
    compact = T)

```

#### Popular gambits

All gambit openings played in the season.



```{r}
# Show gambits played

# Identify games with gambits
gambits <- games %>%
  filter(gambit_col %in% c("white", "black")) %>% 
  mutate(gambit_name = rep(NA, nrow(.)))

# Add gambit names to data

# Iterating through each game in the gambits dataset...
for(i in seq(1:nrow(gambits))){
  test <- gambits$opening.name[i]
  # First check if there's a colon in the opening name
  if(str_detect(test, ":")){
    # If there is, and it appears before "Gambit", extract the substring between the two, including "Gambit"
    if(str_locate(test, ":")[1,1] < str_locate(test, "Gambit")[1,1]){
      result <- str_extract(test, "(?<=:).*Gambit") %>% str_squish()
      # Check the resulting substring for any commas
      if(str_detect(result, ",")){
        # If there's a comma, extract the substring between the comma and "Gambit", again keeping the latter
        result <- str_extract(result, "(?<=,).*Gambit") %>% str_squish()
        # Repeat if there's another comma left in there
        if(str_detect(result, ",")){result <- str_extract(result, "(?<=,).*Gambit") %>% str_squish()}
      } else {
        # If there isn't a comma, don't change the substring
        result <- result
      }
    }
    # If there's a colon and it appears AFTER "Gambit", extract the substring between the start of the string and "Gambit" 
    if(str_locate(test, ":")[1,1] > str_locate(test, "Gambit")[1,1]){
      result <- str_extract(test, "(?<=^).*Gambit") %>% str_squish()
    }
    # If there's no colon in the opening name, keep it the same
  } else{
    result <- test
  }
  gambits$gambit_name[i] <- result
}

# Now make sure all gambit names only have one "Gambit"
gambits <- gambits %>% 
  mutate(gambit_name = str_replace_all(gambit_name, "(?<=Gambit).*$", ""))

gambits <- gambits %>% 
  mutate(gambit_score = case_when(
    gambit_col == "white" & result == "1-0" ~ 1,
    gambit_col == "white" & result == "1/2-1/2" ~ 0.5,
    gambit_col == "white" & result == "0-1" ~ 0,
    gambit_col == "black" & result == "1-0" ~ 0,
    gambit_col == "black" & result == "1/2-1/2" ~ 0.5,
    gambit_col == "black" & result == "0-1" ~ 1,
    TRUE ~ NA_real_
  )) %>%
  select(gambit_name, gambit_score) %>%
  group_by(gambit_name) %>%
  summarise(games = n(),
            success = (sum(gambit_score) / games) * 100) %>%
  # filter(games > 1) %>% 
  arrange(desc(games), desc(success)) %>% 
  mutate(rank = seq(1:nrow(.))) %>% 
  select(rank, gambit_name, games, success)

reactable(gambits,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
          compact = T,
           columns = list(
             rank = colDef(name = "Rank", align = "center", minWidth = 50),
    gambit_name = colDef(name = "Name", minWidth = 150),
    games = colDef(name = "Games", align = "center"),
    success = colDef(name = "White score (%)", format = colFormat(digits = 0), align = "center")
           )
    )
```


#### Gambiteers

The players who enjoyed the most success when playing gambits (min 50% score).

```{r}
# Gambit lovers
gambiteers <- games %>%
  filter(gambit_col %in% c("white", "black")) %>% 
  mutate(player = case_when(
    gambit_col == "white" ~ white,
    gambit_col == "black" ~ black,
    TRUE ~ NA_character_
  )) %>% 
  mutate(gambit_score = case_when(
    gambit_col == "white" & result == "1-0" ~ 1,
    gambit_col == "white" & result == "1/2-1/2" ~ 0.5,
    gambit_col == "white" & result == "0-1" ~ 0,
    gambit_col == "black" & result == "1-0" ~ 0,
    gambit_col == "black" & result == "1/2-1/2" ~ 0.5,
    gambit_col == "black" & result == "0-1" ~ 1,
    TRUE ~ NA_real_
  )) %>% 
  select(id, player, opening.name, gambit_score) %>% 
  group_by(player) %>% 
  summarise(games = n(),
            success = sum(gambit_score) / games) %>%
  # filter(games > 1, success >= 0.5) %>%
  arrange(desc(success), desc(games)) %>% 
  mutate(rank = seq(1:nrow(.))) %>% 
  select(rank, player, games, success)


# gambiteers

reactable(gambiteers,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
          compact = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center", minWidth = 50),
    player = colDef(name = "Player", minWidth = 150),
    games = colDef(name = "Games", align = "center"),
    success = colDef(name = "% Score", format = colFormat(digits = 2), align = "center")
           )
    )
```


#### Sunburst

**Not functional yet.** When it works, you'll be able to click on the image below to see an explorable sunburst plot of all openings played in the season. Currently, it just takes you to the Lichess homepage.

[![Opening star placeholder](https://rahulan-c.github.io/lichess4545-stats/reports/opening_star_placeholder.png)](http://www.lichess.org)


### Player awards

```{r relative_perfs}
perfs_w <- pairings %>% 
  filter(winner != "forfeit/unplayed") %>% 
  group_by(white) %>%
  summarise(sum_opp_rating = sum(rating_b),
            games = n(),
            points = ((sum(winner == "white") * 1) + (sum(winner == "draw") * 0.5)),
            wins = sum(winner == "white"),
            draws = sum(winner == "draw"),
            losses = sum(winner == "black"),
            initial_rating = rating_w[which.min(round)],
            initial_round = min(round)) %>% 
  rename("player" = white)

perfs_b <- pairings %>% 
  filter(winner != "forfeit/unplayed") %>% 
  group_by(black) %>%
  summarise(sum_opp_rating = sum(rating_w),
            games = n(),
            points = ((sum(winner == "black") * 1) + (sum(winner == "draw") * 0.5)),
            wins = sum(winner == "black"),
            draws = sum(winner == "draw"),
            losses = sum(winner == "white"),
            initial_rating = rating_b[which.min(round)],
            initial_round = min(round)) %>% 
  rename("player" = black)

perfs <- rbind(perfs_w, perfs_b)
rm(perfs_w, perfs_b)

# Compute performance ratings using FIDE method
perfs_fide <- perfs %>% 
  group_by(player) %>% 
  summarise(sum_opp_rating = sum(sum_opp_rating),
            games = sum(games),
            avg_opp_rating = sum_opp_rating / games,
            points = sum(points),
            tp_score = points / games,
            wins = sum(wins),
            draws = sum(draws),
            losses = sum(losses),
            initial_rating = initial_rating[which.min(initial_round)]) %>%
  mutate(adj = fide_tpr_lookup[match(round(tp_score, 2), fide_tpr_lookup$p),2]) %>% 
  mutate(perf_rating = avg_opp_rating + adj) %>% 
  mutate(perf_diff = perf_rating - initial_rating)

# Save as all perfs df
perfs <- perfs_fide
rm(perfs_fide)

# Produce relative perfs for report
relative_perfs <- perfs %>% 
  filter(games >= 5) %>% 
  filter(perf_diff >= 0) %>% 
  arrange(desc(perf_diff)) %>% 
  mutate(perf_rank = seq(1:nrow(.))) %>% 
  select(perf_rank, player, games, wins, draws, losses, initial_rating, perf_rating, perf_diff)

```

```{r}
season_error_rates <- error_rates %>% 
  group_by(player) %>% 
  summarise(season_acpl = sum(cpl, na.rm=T) / sum(moves, na.rm=T), 
            total_blunders = sum(blunders, na.rm = T),
            total_mistakes = sum(mistakes, na.rm = T),
            total_inaccuracies = sum(inaccuracies, na.rm = T),
            total_moves = sum(moves, na.rm = T)) %>% 
  filter(total_moves >= 100) %>% 
  arrange(season_acpl)
  
lowest_acpls <- season_error_rates %>% 
  filter(total_moves > 100) %>% 
  head(100) %>%
  mutate(acpl_rank = seq(1:nrow(.))) %>% 
  select(acpl_rank, player, total_moves, season_acpl)
```

```{r}
# Players with single-figure ACPLs

minacpl_players_w <- games %>% 
  arrange(players.white.analysis.acpl) %>% 
  select(white, players.white.analysis.acpl,
         id, result) %>% 
  mutate(colour = "w")
colnames(minacpl_players_w)[1:2] <- c("player", "acpl")

minacpl_players_b <- games %>% 
  arrange(players.black.analysis.acpl) %>% 
  select(black, players.black.analysis.acpl, id, result) %>% 
  mutate(colour = "b")
colnames(minacpl_players_b)[1:2] <- c("player", "acpl")

minacpl_players <- rbind(minacpl_players_w, minacpl_players_b) %>% 
  arrange(acpl) %>% 
  select(player, acpl, id)

rm(minacpl_players_w, minacpl_players_b)

# Show players with multiple single-figure ACPL games
minacpl_players <- minacpl_players %>%  
  filter(acpl < 10) %>% 
  group_by(player) %>% 
  tally() %>% 
  filter(n>1)
```

```{r}
# Clock times spent per move (after move 10)
# Min. games: 3
avg_think_times <- rbind(tibble("player" = games$white, "duration" = games$clock_used_after_move10_w, "moves" = games$num_moves - 10),
                  tibble("player" = games$black, "duration" = games$clock_used_after_move10_b, "moves" = games$num_moves - 10)) %>% 
  filter(moves > 0) %>% 
  group_by(player) %>% 
  summarise(time_spent_after_move10 = sum(duration, na.rm = T),
            moves = sum(moves, na.rm = T),
            games = n(),
            avg_time_spent_after_move10 = time_spent_after_move10 / moves) %>% 
  arrange(desc(avg_time_spent_after_move10)) %>% 
  select(player, games, moves, avg_time_spent_after_move10, time_spent_after_move10) %>% 
  filter(games >= 3) %>% 
  mutate(prank = ntile(avg_time_spent_after_move10, 100)) %>%
  mutate(rank = seq(1:nrow(.))) %>% 
  mutate(duration_print = sprintf('%2dm %2.1fs', lubridate::minute(seconds_to_period(avg_time_spent_after_move10)), lubridate::second(seconds_to_period(avg_time_spent_after_move10)))) %>% 
  select(rank, player, games, moves, duration_print, prank)

# Most think time across season
season_think <- rbind(tibble("player" = games$white, "duration" = games$duration_w, "moves" = games$num_moves),
                                  tibble("player" = games$black, "duration" = games$duration_b, "moves" = games$num_moves)) %>% 
  group_by(player) %>% 
  summarise(total_duration = lubridate::seconds_to_period(sum(duration, na.rm = T)),
            total_moves = sum(moves, na.rm = T),
            games = n()) %>% 
  arrange(desc(total_duration)) %>% 
  mutate(rank = seq(1:nrow(.))) %>% 
  mutate(duration_print = sprintf('%2dh %2dm %2ds', lubridate::hour(total_duration), lubridate::minute(total_duration), lubridate::second(total_duration))) %>% 
  select(rank, player, games, duration_print) %>% 
  head(50)

# Players who've played in the longest games
most_playing_time <- rbind(tibble("player" = games$white, "duration" = games$duration),
                                   tibble("player" = games$black, "duration" = games$duration)) %>% 
  group_by(player) %>% 
  summarise(total_duration = lubridate::seconds_to_period(sum(duration, na.rm = T)),
            games = n()) %>% 
  arrange(desc(total_duration)) %>% 
  head(50) %>% 
  mutate(rank = seq(1:nrow(.))) %>% 
  mutate(duration_print = sprintf('%2gh %2gm %2gs', lubridate::hour(total_duration), lubridate::minute(total_duration), lubridate::second(total_duration))) %>% 
  select(rank, player, games, duration_print)
```


```{r}
# Identify Giri Award winner - most draws
drawers <- pairings %>% 
  filter(winner == "draw") %>% 
  select(white, black)

drawers <- c(drawers$white, drawers$black)

drawers <- tibble("player" = drawers) %>% 
  group_by(player) %>% 
  tally() %>% 
  arrange(desc(n)) %>% 
  slice_max(n)
```


```{r}
# Comebacks

comebacks <- games %>% 
  mutate(end_eval = case_when(
    winner == "white" ~ 1,
    winner == "black" ~ -1,
    status == "draw" ~ 0,
    status == "stalemate" ~ 0,
    TRUE ~ NA_real_
  )) %>% 
  select(id, white, black, end_eval, evals)

comebacks$max_eval <- rep(NA, nrow(comebacks))
comebacks$min_eval <- rep(NA, nrow(comebacks))

for(i in seq(1:nrow(comebacks))){
  comebacks$max_eval[i] <- max(comebacks$evals[i][[1]]$eval_scaled)
  comebacks$min_eval[i] <- min(comebacks$evals[i][[1]]$eval_scaled)
}

comebacks <- comebacks %>% 
  mutate(comeback_w = if_else(end_eval %in% c(0,1), abs(end_eval - min_eval), 0),
         comeback_b = if_else(end_eval %in% c(0,-1), abs(end_eval - max_eval), 0))

cw <- comebacks %>% select("player" = white, "comeback" = comeback_w)
cb <- comebacks %>% select("player" = black, "comeback" = comeback_b)

comebacks_2 <- bind_rows(cw, cb)

comebacks_2 <- comebacks_2 %>% 
  group_by(player) %>% 
  summarise(games = n(),
            total_cb = sum(comeback),
            avg_cb = total_cb / games) %>% 
  arrange(desc(total_cb)) %>%
  filter(games >= 3) %>% 
  filter(avg_cb > 0) %>% 
  mutate("rank" = seq(1:nrow(.))) %>% 
  select(rank, player, avg_cb, total_cb)
```


```{r}
# Biggest upsets
upsets <- pairings %>%
  filter((rating_w < rating_b & winner == "white") |
           (rating_b < rating_w & winner == "black")) %>% 
  mutate(rating_gap = abs(rating_w - rating_b)) %>% 
  select(white, black, winner, rating_gap) %>% 
  mutate(player = if_else(winner == "white", white, black)) %>% 
  arrange(desc(rating_gap)) %>%
  filter(rating_gap >= 50) %>% 
  mutate("rank" = seq(1:nrow(.))) %>% 
  select(rank, player, rating_gap)

# Repeat upset specialists
upset_specialists <- upsets %>% 
  group_by(player) %>% 
  summarise(upsets = n(),
            mean_rating_gap = mean(rating_gap),
            max_rating_gap = max(rating_gap),
            upset_pts = sum(rating_gap)) %>%
  filter(upsets > 1) %>% 
  arrange(desc(upset_pts)) %>% 
  mutate("rank" = seq(1:nrow(.))) %>% 
  select(rank, player, upset_pts, upsets, mean_rating_gap, max_rating_gap)

```


```{r, eval = FALSE}
# Players with most total pawn moves
pawn_moves <- tibble("id" = games$id,
                       "white" = games$white,
                       "pawn_moves_w" = rep(NA, nrow(games)),
                       "black" = games$black,
                       "pawn_moves_b" = rep(NA, nrow(games)))

for(i in seq(1:nrow(games))){
  pawn_moves$pawn_moves_w[i] <- sum(str_count(str_sub(str_extract_all(games$moves[i], "[:graph:]+(\\s|$)")[[1]], 1, 1), "[:lower:]")[c(T,F)])
  pawn_moves$pawn_moves_b[i] <- sum(str_count(str_sub(str_extract_all(games$moves[i], "[:graph:]+(\\s|$)")[[1]], 1, 1), "[:lower:]")[c(F,T)])
}

pawn_moves <- pawn_moves %>% 
  mutate(combined = pawn_moves_w + pawn_moves_b) %>% 
  arrange(desc(combined))

pawn_moves_collated <- rbind(tibble("player" = pawn_moves$white, "moves" = pawn_moves$pawn_moves_w),
                             tibble("player" = pawn_moves$black, "moves" = pawn_moves$pawn_moves_b)) %>%
  group_by(player) %>% 
  summarise(moves = sum(moves)) %>% 
  arrange(desc(moves)) %>% 
  mutate("rank" = seq(1:nrow(.))) %>% 
  select(rank, player, moves) %>% 
  filter(moves >= 10)
```


```{r}
# Other Grischuk Award: least time left after move 10
dawdlers <- data.table::rbindlist(games$evals) %>% 
  filter(ply %in% c(18, 19)) %>%
  arrange(time_left)

dawdlers <- left_join(dawdlers, games, by = c("game_id" = "id")) %>% 
  select("id" = game_id, ply, eval, time_left, white, black, result) %>% 
  mutate(player = if_else(ply %% 2 == 1, black, white),
         outcome = case_when(
           player == white & result == "1-0" ~ "Win",
           player == white & result == "0-1" ~ "Loss",
           player == black & result == "1-0" ~ "Loss",
           player == black & result == "0-1" ~ "Win",
           result == "1/2-1/2" ~ "Draw",
           TRUE ~ NA_character_
         )) %>%
  mutate(url = paste0("https://lichess.org/", id, "#", ply+1)) %>% 
  select(player, url, time_left, outcome) %>% 
  arrange(time_left) %>% 
  mutate(time_left_2 = lubridate::seconds_to_period(time_left)) %>% 
  mutate("rank" = seq(1:nrow(.))) %>% 
  mutate(time_print = sprintf('%2dm %2ds', lubridate::minute(time_left_2), lubridate::second(time_left_2))) %>% 
  select(rank, player, time_print, outcome, url) %>% 
  head(100)
```

```{r}
# Players with the most near-instant moves (< 0.5s)

instamovers <- data.table::rbindlist(games$evals) %>% 
  filter(time_spent < 1)

instamovers <- left_join(instamovers, games, by = c("game_id" = "id")) %>% 
  select("id" = game_id, ply, time_spent, white, black, result) %>% 
  mutate(player = if_else(ply %% 2 == 1, black, white)) %>% 
  group_by(player) %>% 
  summarise(instamoves = n()) %>% 
  arrange(desc(instamoves)) %>% 
  mutate("rank" = seq(1:nrow(.))) %>% 
  select(rank, player, instamoves)
```


```{r}
# Longest movetimes (top 100)
movetimes <- data.table::rbindlist(games$evals) %>% 
  mutate(colour = case_when(
    ply %% 2 == 0 ~ "white",
    ply %% 2 == 1 ~ "black",
    TRUE ~ NA_character_
  )) %>% 
  arrange(desc(time_spent))

games_basics <- games %>% select(id, white, black)

movetimes <- left_join(movetimes, games_basics, by = c("game_id" = "id")) %>% 
  mutate(player = ifelse(colour == "white", white, black),
         rank = seq(1:nrow(.)),
         url = paste0("https://lichess.org/", game_id, "#", ply+1)) %>% 
  select(rank, player, time_spent, colour, ply, url) %>%
  mutate(time_spent = lubridate::seconds_to_period(time_spent),
         move = ifelse(ply %% 2 == 0, ply/2+1, (ply/2)+0.5)) %>% 
  mutate(time_spent = sprintf('%2dm %2ds', lubridate::minute(time_spent), lubridate::second(time_spent))) %>% 
  mutate(colour = str_to_title(colour)) %>% 
  select(rank, player, time_spent, colour, move, url) %>% 
  head(100)
```

```{r}
all_moves <- data.table::rbindlist(games$evals) %>% 
  mutate(colour = case_when(
    ply %% 2 == 0 ~ "white",
    ply %% 2 == 1 ~ "black",
    TRUE ~ NA_character_
  )) 

games_basics <- games %>% select(id, white, black, winner)

all_moves <- left_join(all_moves, games_basics, by = c("game_id" = "id")) %>% 
  mutate(player = ifelse(colour == "white", white, black)) %>% 
  group_by(player) %>% 
  add_tally() %>% 
  rename("player_total_moves" = n) %>% 
  mutate(player_outcome = case_when(
    colour == "white" & winner == "white" ~ "win",
    colour == "black" & winner == "black" ~ "win",
    TRUE ~ NA_character_
  ))
```



```{r}
# Saved by the bell
savedbythebell <- all_moves %>% 
  filter(time_left < 6,
         player_outcome == "win") %>%
  select(player, game_id, white, black) %>% 
  group_by(player, game_id) %>% 
  summarise(panic_moves = n()) %>% 
  arrange(desc(panic_moves)) %>% 
  mutate(url = paste0("https://lichess.org/", game_id)) %>% 
  select(player, panic_moves, url)

```


```{r}
# Highest % of moves in time trouble (<60s)
timetrouble <- all_moves %>% 
  filter(time_left < 60) %>% 
  group_by(player) %>% 
  summarise(tt_moves = n(),
            moves = max(player_total_moves),
            tt_pc = tt_moves/moves) %>% 
  arrange(desc(tt_pc)) %>% 
  mutate(rank = seq(1:nrow(.))) %>% 
  filter(moves > 100) %>% # min threshold 100 moves
  select(rank, player, moves, tt_moves, tt_pc)
```

```{r radjabov_award}
# Radjabov Award: find draws agreed in winning positions

# Extract all moves from games data
all_moves <- data.table::rbindlist(games$evals) %>% 
  mutate(colour = case_when(
    ply %% 2 == 0 ~ "white",
    ply %% 2 == 1 ~ "black",
    TRUE ~ NA_character_
  )) 

# Add game ID, player names, and the result
games_basics <- games %>% select(id, white, black, result)

all_moves <- left_join(all_moves, games_basics, by = c("game_id" = "id")) %>% 
  mutate(player = ifelse(colour == "white", white, black))

radjabov <- all_moves %>% 
  group_by(game_id) %>% 
  slice(which.max(ply)) %>%
  summarise(result = result,
            white = white,
            black = black, 
            final_ply = ply,
            final_eval = eval_scaled,
            abs_final_eval = abs(final_eval)) %>% 
  filter(result == "1/2-1/2") %>% 
  arrange(desc(abs_final_eval)) %>% 
  mutate(player = ifelse(final_eval > 0, white, black)) %>% 
  head(3)

```


```{r david_award}
# David Award (suggested by Tranzoo)
# For the player who faced the opponents with the highest collective score across
# the season (excluding games against the player)

david <- games %>% 
  select(white, black, result, score_w, score_b) %>%
  left_join(perfs, by = c("white" = "player")) %>% 
  select(white, black, score_w, score_b, "games_w" = games, "points_w" = points) %>% 
  mutate(games_aw = games_w - 1, points_aw = points_w - score_w) %>% 
  left_join(perfs, by = c("black" = "player")) %>% 
  select(white, black, score_w, score_b, games_aw, points_aw, "games_b" = games, "points_b" = points) %>%
  mutate(games_ab = games_b - 1, points_ab = points_b - score_b) %>% 
  select(white, black, games_aw, games_ab, points_aw, points_ab)

david <- rbind(tibble("player" = david$white,
                      "opp_adjgames" = david$games_ab,
                      "opp_adjpoints" = david$points_ab),
               tibble("player" = david$black,
                      "opp_adjgames" = david$games_aw,
                      "opp_adjpoints" = david$points_aw)) %>% 
  group_by(player) %>% 
  summarise(opp_games = sum(opp_adjgames),
            opp_points = sum(opp_adjpoints),
            opp_perc = opp_points / opp_games) %>% 
  arrange(desc(opp_perc))
  
  
```

```{r team_stats, eval = ifelse(league == "team4545", TRUE, FALSE)}
# Compute team stats

# Gather team-specific data
# team_data_from_pairings <- pairings %>% 
#   select(match, round, board, white, black, result, team_w, team_b, gp_w, gp_b, team_res_w, team_res_b)

team_data <- games %>% 
  select(season, round, board, id, white, black, result, num_moves, score_w, 
         score_b, team_w, team_b, gp_w, gp_b,
         "acpl_w" = players.white.analysis.acpl,
         "acpl_b" = players.white.analysis.acpl,
         "blunders_w" = players.white.analysis.blunder,
         "blunders_b" = players.black.analysis.blunder,
         duration, duration_w, duration_b, eval_after_15, evals,
         match
         )

team_data_w <- tibble("team" = team_data$team_w, "player" = team_data$white,
                      "score" = team_data$score_w, "board" = team_data$board,
                      "acpl" = team_data$acpl_w, "blunders" = team_data$blunders_w,
                      "moves" = team_data$num_moves, "game_duration" = team_data$duration,
                      "player_duration" = team_data$duration_w,
                      "cpl" = team_data$acpl_w * team_data$num_moves)
team_data_b <- tibble("team" = team_data$team_b, "player" = team_data$black,
                      "score" = team_data$score_b, "board" = team_data$board,
                      "acpl" = team_data$acpl_b, "blunders" = team_data$blunders_b,
                      "moves" = team_data$num_moves, "game_duration" = team_data$duration,
                      "player_duration" = team_data$duration_b,
                      "cpl" = team_data$acpl_w * team_data$num_moves)

team_data <- rbind(team_data_w, team_data_b) %>% 
  group_by(team) %>% 
  summarise(players = n_distinct(player),
            games = n(),
            pts_nonforf = sum(score, na.rm = T),
            wins = sum(score == 1, na.rm = T),
            draws = sum(score == 0.5, na.rm = T),
            losses = sum(score == 0, na.rm = T),
            acpl = sum(cpl, na.rm = T) / sum(moves, na.rm = T),
            avg_moves = mean(moves, na.rm = T),
            blunder_pc = sum(blunders, na.rm = T) / sum(moves, na.rm = T)
  )

rm(team_data_w, team_data_b)

# Add teams' final game points total (incl. forfeits/sched. draws etc) to team data
team_points <- positions %>%
  filter(round == 8) %>% 
  select(rank, team, "points" = gp)

team_data <- left_join(team_data, team_points, by = c("team"))

# Get lowest team ACPL for awards
team_accuracy_award <- team_data %>% 
  arrange(acpl) %>% 
  filter(!(is.na(team))) %>%
  slice_min(acpl) %>% 
  select(team, acpl)


```


```{r egalitarianism, eval = ifelse(league == "team4545", TRUE, FALSE)}
# ---- MOST EGALITARIAN TEAMS ----
# Silkthewander's suggestion
# Award for the team with the lowest standard deviation of players' relative performance ratings over the season, 
# where one's rel. perf rating = their actual perf. rating minus their initial rating

# Gather data on all players and their teams
players_teams <- rbind(tibble("player" = games$white, "team" = games$team_w, "round" = games$round),
                       tibble("player" = games$black, "team" = games$team_b, "round" = games$round)) %>% 
  group_by(player, team) %>% 
  summarise(games = n()) 

# Construct variant dataset for obtaining relative perf ratings 
players_teams_2 <- players_teams %>% 
  mutate(player = str_to_lower(player))

# Compute team egalitarianism score
egalitarian <- players_teams %>% 
  left_join(perfs, by = c("player")) %>% 
  group_by(team) %>% 
  summarise(egalite = sd(perf_diff, na.rm = T)) %>% 
  arrange(egalite) %>% 
  filter(!(is.na(team)))




```


```{r alts, eval = ifelse(league == "team4545", TRUE, FALSE)}
# Highlight alternates
# Criteria: played for more than 1 team, or played only 1 game
alts <- players_teams %>% 
  group_by(player) %>% 
  summarise(games = sum(games, na.rm = T),
            teams = n_distinct(team)) %>% 
  filter(teams > 1 | games == 1) %>% 
  arrange(desc(teams)) %>% 
  mutate(rank = min_rank(-teams))

# Identify player who played for the most teams
alt_award <- alts %>% filter(rank == 1) 

# Identify player(s) who played for the second-highest number of teams
alt_runnerup <- alts %>% 
  filter(rank > 1) %>% 
  slice_max(teams)



```

```{r player_awards}

single_fig_acpl_players <- minacpl_players %>% select(player) %>% pull()
giri_winners <- drawers %>% select(player) %>% pull()
giri_value <- drawers %>% select(n) %>% distinct() %>% pull()
alt_winners <- alt_award %>% select(player) %>% pull()
alt_value <- alt_award %>% select(teams) %>% pull()
alt_runnerup_names <- alt_runnerup %>% select(player) %>% pull()
alt_runnerup_value <- alt_runnerup %>% select(teams) %>% distinct() %>% pull() 

awards <- tibble("Image" = c(rep("x", 18)),
                 "Award" = c("Gambit Guru",
                             "MVP Award",
                             "Archbishop of Accuracy",
                             "Primates of Precision",
                             "Tetrarch of Time",
                             "Giri Award",
                             "Houdini Award",
                             "Tarjan Award",
                             "Slingshot Specialist",
                             "Grischuk's Cousin",
                             "Bullet Boss",
                             "Musing or Snoozing",
                             "Intimate with Increment",
                             "Saved by the Bell",
                             "Radjabov Award",
                             "David Award",
                             ifelse(league == "team4545", "Awesome Alt", NA),
                             ifelse(league == "team4545", "Team Accuracy", NA)
                             ),
                 
                 "Definition" = c("Best score playing gambits",
                                  "Best performance rating relative to initial rating",
                                  "Lowest ACPL",
                                  "Achieved single-figure ACPLs more than once",
                                  "Most time spent per move (after move 10)",
                                  "Most draws",
                                  "Biggest comebacks",
                                  "Biggest upset in a single game",
                                  "Biggest upsets overall",
                                  "Least time remaining after 10th move",
                                  "Most moves made in under 0.5s",
                                  "Longest time spent on a move",
                                  "Highest percentage of moves played with < 1 min left",
                                  "Most moves made with < 5s left before winning",
                                  "Securing a draw from the jaws of victory",
                                  "Faced the strongest schedule (in terms of their opponents' collective record)",
                                  "Played for the most teams during the season",
                                  "Lowest team ACPL"),
                 
                 "Winner" = c(gambiteers$player[1],
                              relative_perfs$player[1],
                              lowest_acpls$player[1],
                              str_c(single_fig_acpl_players, collapse = ", "),
                              avg_think_times$player[1],
                              str_c(giri_winners, collapse = ", "),
                              comebacks_2$player[1],
                              upsets$player[1],
                              upset_specialists$player[1],
                              dawdlers$player[1],
                              instamovers$player[1],
                              movetimes$player[1],
                              timetrouble$player[1],
                              savedbythebell$player[1],
                              radjabov$player[1],
                              david$player[1],
                              str_c(alt_winners, collapse = ", "),
                              team_accuracy_award$team[1]
                              ),
                 
                 "Details" = c(paste0(round(gambiteers$success[1] * 100), "% from ", gambiteers$games[1], " games"),
                              paste0("Perf. rating: ", round(relative_perfs$perf_rating[1], 0), ", Initial rating: ",
                                     relative_perfs$initial_rating[1]),
                              paste0(round(lowest_acpls$season_acpl[1], 1), " (", lowest_acpls$total_moves[1], ")"),
                              "",
                              paste0(avg_think_times$duration_print[1]),
                              "",
                              "",
                              paste0("Beat an opponent ", upsets$rating_gap[1], " points higher rated"),
                              paste0(upset_specialists$upsets[1], " upsets (", "biggest: ", upset_specialists$max_rating_gap[1], " pts)"),
                              paste0("Had ", dawdlers$time_print[1], " left in ", dawdlers$url[1], " (eventual ", dawdlers$outcome[1], ")"),
                              instamovers$instamoves[1],
                              paste0("Spent ", movetimes$time_spent[1], " on ", movetimes$url[1]),
                              paste0(round(timetrouble$tt_pc[1]*100, 1), "% (", timetrouble$tt_moves[1], "/", timetrouble$moves[1], ")"),
                              paste0(savedbythebell$panic_moves[1], " move(s) in ", savedbythebell$url[1]),
                              "",
                             paste0("Opponents' record: ", david$opp_points[1], "/", david$opp_games[1]),
                             paste0("Played for ", alt_value, " different teams"),
                             paste0("Team ACPL: ", round(team_accuracy_award$acpl[1], 1))
                             ),
                 
                 "Mentions" = c(str_c(gambiteers$player[2:3], collapse = ", "),
                              str_c(relative_perfs$player[2:3], collapse = ", "),
                              str_c(lowest_acpls$player[2:3], collapse = ", "),
                              "",
                              str_c(avg_think_times$player[2:3], collapse = ", "),
                              paste0("Achieved ", giri_value, " draws"),
                              str_c(comebacks_2$player[2:3], collapse = ", "),
                              str_c(upsets$player[2:3], collapse = ", "),
                              str_c(upset_specialists$player[2:3], collapse = ", "),
                              str_c(dawdlers$player[2:3], collapse = ", "),
                              str_c(instamovers$player[2:3], collapse = ", "),
                              str_c(movetimes$player[2:3], collapse = ", "),
                              str_c(timetrouble$player[2:3], collapse = ", "),
                              str_c(savedbythebell$player[2:3], collapse = ", "),
                              str_c(radjabov$player[2:3], collapse = ", "),
                              str_c(david$player[2:3], collapse = ", "),
                              paste0(str_c(alt_runnerup_names, collapse = ", "), " (", alt_runnerup_value, ")"),
                              "")
                 
                 )

# Re-arrange columns
awards <- awards %>% 
  select(Image, Award, Definition, Winner, Details, Mentions) %>% 
  arrange(Award) %>% 
  filter(!(is.na(Award)))

# Show player awards table
reactable(awards,
          pagination = F,
          highlight = F,
          striped = T,
          searchable = F,
          fullWidth = T,
          resizable = T,
          outlined = T,
          compact = F,
          columns = list(
            Image = colDef(name = "Award", 
                           cell = function(value, index) {
                             award_name <- awards$Award[index]
                             image <- img(src = sprintf("https://rahulan-c.github.io/lichess4545-stats/reports/images/%s.png", award_name), height = "60px", alt = award_name)
              tagList(
                div(style = list(display = "inline-block", width = "60px"), image)
                )
              }),
            Award = colDef(name = "Description", minWidth = 200,
                           # Show award definition/criteria under each name
                           cell = function(value, index) {
                             definition <- awards$Definition[index]
                             definition <- if (!is.na(definition)) definition else "n/a"
                             tagList(
                               div(style = list(fontWeight = 600), value),
                               div(style = list(fontSize = 12), definition)
                               )
                             }),
            Winner = colDef(name = "Winner", minWidth = 200),
            Definition = colDef(show = F),
            Details = colDef(name = "Details", minWidth = 200),
            Mentions = colDef(name = "Honourable mentions", minWidth = 150)
          )
)

```

### Appendix


#### Best performance ratings / highest accuracy  {.tabset}

The following five sections present various player-based statistics. See if you can spot your name in the tables. Most tables are sortable and searchable, but also have specified inclusion criteria.

##### Best relative perfs

Shows all players who achieved a performance rating (over a minimum of 5 games) that exceeded their initial rating.  

*For some reason, these performance ratings tend to differ slightly from the values that are shown on players' Lichess4545 season profile pages. I don't know why they're different, but they're similar enough that it doesn't matter. For what it's worth, I use FIDE's method (which the website does too), and I ignore all unplayed games such as forfeits and scheduling draws.*


```{r}
# Table for report
reactable(relative_perfs,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             perf_rank = colDef(name = "#", align = "center", minWidth = 40),
    player = colDef(name = "Player", minWidth = 250),
    games = colDef(name = "Games", align = "center", minWidth = 60),
    wins = colDef(name = "W", align = "center", minWidth = 40),
    draws = colDef(name = "D", align = "center", minWidth = 40),
    losses = colDef(name = "L", align = "center", minWidth = 40),
    initial_rating = colDef(name = "Initial", align = "center", minWidth = 70),
    perf_rating = colDef(name = "Perf", format = colFormat(digits = 0), align = "center", minWidth = 70),
    perf_diff = colDef(name = "Diff.", format = colFormat(digits = 0), align = "center", minWidth = 70)),
    compact = TRUE)
```


##### Lowest ACPL

*Only the top 100 players are shown. Min. 100 moves played.*

```{r show_lowest_acpls}
reactable(lowest_acpls,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             acpl_rank = colDef(name = "Rank", align = "center"),
    player = colDef(name = "Player", minWidth = 150),
    total_moves = colDef(name = "Moves", align = "center"),
    season_acpl = colDef(name = "ACPL", format = colFormat(digits = 2), align = "center")),
    compact = TRUE)
```

##### Multiple single-figure ACPLs

Players with single-figure ACPLs in more than one game over the season.

```{r accurate_players}
reactable(minacpl_players, fullWidth = F, compact = T,
          columns = list(
            player = colDef(name = "Player", minWidth = 150),
            n = colDef(name = "Games", align = "center")
          ))

```



#### Time spent, comebacks and upsets {.tabset}

##### Time spent

The top 50 players by total clock time spent over the season.

```{r}

reactable(season_think,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center"),
    player = colDef(name = "Player", minWidth = 150),
    games = colDef(name = "Games", align = "center"),
    duration_print = colDef(name = "Total time spent")),
    compact = TRUE)

```

##### Time spent per move (after move 10)

*This table shows everyone who played at least three games during the season.*

```{r thinkers}

reactable(avg_think_times,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center"),
    player = colDef(name = "Player", minWidth = 150),
    games = colDef(name = "Games", align = "center"),
    moves = colDef(name = "Moves", align = "center"),
    duration_print = colDef(name = "Time spent per move", minWidth = 150),
    prank = colDef(name = "Percentile", align = "center")),
    compact = TRUE)
  

```



#### Draws, comebacks, upsets {.tabset}
##### Most draws

The players who had the most draws over the season.

```{r giri_award}
reactable(drawers, fullWidth = F, compact = TRUE,
          columns = list(
            player = colDef(name = "Player", minWidth = 170),
            n = colDef(name = "Draws", align = "center")
          ))

```


##### Comebacks

Originally suggested by **Lou-E**. 

This table shows players ranked by the size and number of comebacks achieved over the course of the season.

For this purpose, the size of a comeback has been defined as the difference between a player's final score in a game (0, 0.5, or 1) and the worst evaluation during the game that they faced (which is then converted into a rough win probability for their opponent).

For example, if I were to win a game after Lichess's server analysis gave my opponent a 75% chance of winning in a certain position, then I would have earned 1.75 comeback "points" from the game. My opponent of course would have earned zero points. If the game had been drawn, I would have instead earned only 0.75 comeback "points".

*Only those who played at least three games in the season and who have a positive average comeback margin are included.*

```{r comebacks}

reactable(comebacks_2,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
          compact = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center", minWidth = 50),
    player = colDef(name = "Player", minWidth = 150),
    avg_cb = colDef(name = "Average Comeback Margin", format = colFormat(digits = 2), align = "center"),
    total_cb = colDef(name = "Total Comeback Margin", format = colFormat(digits = 2), align = "center")
    )
)

```


##### Biggest upsets

*Includes all players who defeated an opponent rated at least 50 points higher.* 

```{r biggest_upsets}
reactable(upsets,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
          compact = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center", minWidth = 50),
    player = colDef(name = "Player", minWidth = 100),
    rating_gap = colDef(name = "Upset Margin", align = "center")
    )
)
```

##### Repeated upsets

Includes players who achieved multiple wins over opponents rated at least 50 points higher.

```{r}

reactable(upset_specialists,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
          compact = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center", minWidth = 50),
    player = colDef(name = "Player", minWidth = 150),
    upset_pts = colDef(name = "Total Upset Margin", align = "center"),
    upsets = colDef(name = "Upsets", align = "center"),
    mean_rating_gap = colDef(name = "Avg Upset Margin", align = "center", format = colFormat(digits = 1)),
    max_rating_gap = colDef(name = "Biggest Margin", align = "center")
    )
)

```



#### Dawdlers and instant movers  {.tabset}

##### Least time left after move 10

Originally suggested by **Silkthewanderer**.

Shows the players who had the least time remaining after their 10th move in a game. 

*Includes the 100 top instances by this measure.*

```{r other_grischuk}

reactable(dawdlers,
          pagination = TRUE,
          searchable = TRUE,
          fullWidth = FALSE,
          resizable = TRUE,
          compact = TRUE,
          columns = list(
            rank = colDef(name = "Rank",
                          align = "center",
                          minWidth = 50),
            player = colDef(name = "Player", minWidth = 150),
            time_print = colDef(name = "Time left after 10 moves", minWidth = 120),
            url = colDef(name = "Link",
                           minWidth = 250,
                           html = TRUE, 
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', dawdlers$url[index], value)
          }),
          outcome = colDef(name = "Result", align = "center")))

```



##### Instant moves 

The players who made the most moves over the season while taking less than 0.5 seconds.

*Includes all players who made at least one such move.*

```{r instamoves}

reactable(instamovers,
          pagination = TRUE,
          searchable = TRUE,
          fullWidth = FALSE,
          resizable = TRUE,
          compact = TRUE,
          columns = list(
            rank = colDef(name = "Rank", align = "center", minWidth = 50),
            player = colDef(name = "Player", minWidth = 150),
            instamoves = colDef(name = "Instant moves", align = "center")
          ))
    
```

#### Longest thinks, time trouble addicts, and lucky escapes {.tabset}

##### Longest thinks

The longest times spent on a single move.

*Top 100 shown.*

```{r}
reactable(movetimes,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "#", align = "center"),
    player = colDef(name = "Player", minWidth = 250),
    time_spent = colDef(name = "Time spent"),
    colour = colDef(name = "Colour", align = "center"),
    move = colDef(name = "Move", align = "center"),
    url = colDef(name = "Link",
                           minWidth = 250,
                           html = TRUE, 
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', movetimes$url[index], value)
          })),
    compact = TRUE)

```

##### Time trouble addicts

Shows players by proportion of moves made in time trouble (defined as having less than a minute remaining on the clock).

*Includes everyone who played at least 100 moves over the season while making at least one move in time trouble.*

```{r}

reactable(timetrouble,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "#", align = "center"),
    player = colDef(name = "Player", minWidth = 250),
    moves = colDef(name = "All moves", align = "center"),
    tt_moves = colDef(name = "With < 1min left", align = "center"),
    tt_pc = colDef(name = "Time Trouble %",
                   align = "center",
                   format = colFormat(digits = 1, percent = TRUE))),
    compact = TRUE)


# format = colFormat(digits = 2)
```

##### Saved by the bell

Games where a player moved with only 5 seconds left on their clock...and still won!

```{r}
reactable(savedbythebell,
          fullWidth = FALSE,
          resizable = TRUE,
          compact = TRUE,
          columns = list(
            player = colDef(name = "Player", minWidth = 150),
            panic_moves = colDef(name = "Moves with under 5s left", align = "center", minWidth = 110),
            url = colDef(name = "Link",
                           minWidth = 250,
                           html = TRUE, 
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', savedbythebell$url[index], value)
          })))

```







#### Team stats (4545 only)

```{r team_stats_appendix, eval = ifelse(league == "team4545", TRUE, FALSE)}
# Show team stats table in appendix
team_data
```



####  Misc. facts {.tabset}

##### Lesser spotted mates

```{r piece_checkmates}
# Checkmates by piece
mates <- tibble("id" = games$id,
                "mates" = rep(NA, nrow(games)))

for(i in seq(1:nrow(games))){
  mates$mates[i] <- str_extract(games$pgn[i], "\\s[:alnum:]+(?<!\\s)#") %>% str_squish()
}

mates <- mates %>% 
  filter(!(is.na(mates))) %>% 
  mutate(mating_piece = str_sub(mates, 1, 1))

all_mates <- mates %>% 
  mutate(status = replace(mating_piece, mating_piece %in% letters[1:8], "P")) %>%
  rename("piece" = status) %>%
  group_by(piece) %>% 
  tally() %>% 
  arrange(desc(n))

# all_mates %>% 
#   kable(caption = "Checkmates") %>% 
#   kableExtra::kable_classic(full_width = F, html_font = "arial", position = "left")
  
# List all games with pawn mates
pawn_mate_games <- mates %>% 
  filter(!(mating_piece %in% c("Q", "R", "B", "N"))) %>% 
  mutate(url = paste0("https://lichess.org/", id)) %>% 
  select(url) %>% 
  pull()

knight_mate_games <- mates %>% 
  filter(mating_piece == "N") %>% 
  mutate(url = paste0("https://lichess.org/", id)) %>% 
  select(url) %>% 
  pull()

```


A pawn gave checkmate in `r length(pawn_mate_games)` games: `r pawn_mate_games`.


A knight gave checkmate in `r length(knight_mate_games)` games: `r knight_mate_games`.


##### Promotions

```{r promotions}
# Promotion stats
promotions <- tibble("url" = paste0("https://lichess.org/", games$id),
                       "promotions" = rep(0, nrow(games)),
                     "promotion_movetext" = rep(NA, nrow(games)))

promotion_moves <- str_extract_all(games$pgn, "[:alnum:]+(?<!\\s)=[:alnum:]")

for(i in seq(1:nrow(games))){
  promotions$promotions[i] <- length(promotion_moves[[i]])
  if(promotions$promotions[i] == 1){
    promotions$promotion_movetext[i] <- promotion_moves[[i]]
  }
  if(promotions$promotions[i] > 1){
    promotions$promotion_movetext[i] <- str_c(promotion_moves[[i]], collapse = " ")
  }
}

promotions <- promotions %>% 
  filter(promotions > 0) %>% 
  arrange(desc(promotions))

underpromotions <- promotions %>% 
  filter(str_detect(promotion_movetext, "N|B|R"))

most_promotions <- promotions %>% 
  slice_max(promotions) %>% 
  select(url) %>% 
  pull()

```

`r nrow(promotions)` games had at least one promotion. `r nrow(underpromotions)` of these saw an under-promotion.

The most promotions seen in a game was `r max(promotions$promotions)`: `r most_promotions`

##### Rollercoaster games

```{r yoyos}
# Identify yo-yo games

# Collate all obtained move-level data
moves <- data.table::rbindlist(games$evals)

# Identify number yo-yo games
yoyos <- moves %>% 
  group_by(game_id) %>% 
  summarise(yoyo = ifelse(max(eval_scaled) > 0.75, ifelse(min(eval_scaled) < -0.75, TRUE, FALSE), FALSE)) %>% 
  filter(yoyo == TRUE) %>% 
  nrow()


```

`r yoyos` games featured significant winning chances for both sides (as identified by Lichess's server analysis), comprising `r round((yoyos / nrow(games)) * 100, 1)`% of all games played.

##### Checks and captures


```{r most_consecutive_checks}
# Find games with most consecutive checks and captures
lst_checks <- list()
lst_captures <- list()

for(i in seq(1:nrow(games))){
  
  checks <- tibble(url = rep(paste0("https://lichess.org/", games$id[i]), games$num_moves[i]),
                    move_num = seq(1:games$num_moves[i]),
                    white_text = rep("", games$num_moves[i]),
                    black_text = rep("", games$num_moves[i]))
  
  movetext <- str_extract_all(games$moves[i], "[:alpha:]+[:graph:]+")
  
  captures <- tibble(url = rep(paste0("https://lichess.org/", games$id[i]), length(movetext[[1]])),
                     ply_num = seq(1:length(movetext[[1]])),
                     text = movetext[[1]])
  
  if(length(movetext[[1]]) %% 2 == 1){movetext[[1]] <- c(movetext[[1]], NA)}
  
  checks$white_text <- movetext[[1]][c(T,F)]
  checks$black_text <- movetext[[1]][c(F,T)]
  
  lst_checks[[i]] <- checks
  lst_captures[[i]] <- captures
}

checks <- rbindlist(lst_checks)
captures <- rbindlist(lst_captures)

checks$is_check_w <- ifelse(str_detect(checks$white_text, "\\+"), 1, 0)
checks$is_check_b <- ifelse(str_detect(checks$black_text, "\\+"), 1, 0)

captures$is_capture <- ifelse(str_detect(captures$text, "x"), 1, 0)

# Isolate checks by colour
checks_w <- checks %>% 
  select(-c("black_text", "is_check_b")) %>% 
  rename("is_check" = "is_check_w")

checks_b <- checks %>% 
  select(-c("white_text", "is_check_w")) %>% 
  rename("is_check" = "is_check_b")

# For each colour set, find the games with the most consecutive checks

# White
check_streaks_w <- checks_w %>% 
  group_by(url) %>%
  do({tmp <- with(rle(.$is_check == T), lengths[values])
  data.frame(url = .$url, Max=if(length(tmp)==0) 0
             else max(tmp)) }) %>%
  slice(1L) %>%
  arrange(desc(Max)) %>%
  rename("streak" = Max) %>%
  as_tibble() %>%
  slice_max(streak)

# Black
check_streaks_b <- checks_b %>%
  group_by(url) %>%
  do({tmp <- with(rle(.$is_check == T), lengths[values])
  data.frame(url = .$url, Max=if(length(tmp)==0) 0
             else max(tmp)) }) %>%
  slice(1L) %>%
  arrange(desc(Max)) %>%
  rename("streak" = Max) %>%
  as_tibble() %>%
  slice_max(streak)

# Captures
capture_streaks <- captures %>%
  group_by(url) %>%
  do({tmp <- with(rle(.$is_capture == T), lengths[values])
  data.frame(url = .$url, Max=if(length(tmp)==0) 0
             else max(tmp)) }) %>%
  slice(1L) %>%
  arrange(desc(Max)) %>%
  rename("streak" = Max) %>%
  as_tibble() %>%
  slice_max(streak)

# Combine to get games with most consecutive checks by White and Black 
check_streaks <- bind_rows(check_streaks_w, check_streaks_b) %>% 
  arrange(desc(streak)) %>%
  slice_max(streak)

capture_streaks <- capture_streaks %>% 
  arrange(desc(streak)) %>%
  slice_max(streak)

check_streaks_games <- check_streaks %>% 
  select(url) %>% 
  pull()

capture_streaks_games <- capture_streaks %>% 
  select(url) %>% 
  pull()

# Find game with latest first capture
latest_first_capture <- captures %>%
  filter(is_capture == 1) %>% 
  group_by(url) %>% 
  summarise(first_capture = min(ply_num)) %>% 
  slice_max(first_capture)

game_latest_capture <- latest_first_capture %>% 
  select(url) %>% pull()

```


- Most consecutive checks: `r max(check_streaks$streak)` (`r check_streaks_games`)
- Most consecutive captures: `r max(capture_streaks$streak)` (`r capture_streaks_games`)
- Latest-occurring first capture: ply `r max(latest_first_capture$first_capture)` in  `r game_latest_capture`


### About  

- This report was compiled on `r format(Sys.time(), '%d %B %Y')`.
- It uses data on player/team pairings and results from the Lichess4545 website combined with game data provided by Lichess. 
- Note that the data excludes all players who are currently banned by Lichess for violating their Terms of Service (at the time the report was compiled). This can mean that players who are listed in the final standings on the Lichess4545 website are missing from the statistics presented here.
- Although tournament performance ratings have been calculated using FIDE's method, they may differ slightly from figures published on the Lichess4545 website.
- Currently, ties are not properly handled when determining player awards, which may cause errors.
- Also, the code that produces the stats does not implement tiebreaks to determine the top three 4545 teams. This usually works out fine, but it can lead to errors in seasons where the top positions were determined by tiebreaks -- most notably in Season 11.
- Icons for player awards: [Noun Project](https://thenounproject.com/)

```{=html}
&nbsp;
<hr />
<p style="text-align: center;">Stats produced by <a href="https://lichess.org/@/izzie26">izzie26</a></p>
<p style="text-align: center;"><span style="color: #808080;"><em>Want to help with the ledger? Ask in #lichessledger</em></span></p>

&nbsp;
```


