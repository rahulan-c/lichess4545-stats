---
output:
  html_document:
    css: style.css
    theme: flatly
    dev: svglite
    toc: yes
    toc_depth: 4
    toc_float: true
    includes:
      in_header: header.html
title: "`r paste0('Season summary: ', ifelse(league == 'lonewolf', 'LoneWolf', '4545 League'), ifelse(lw_section == 'open', ' (Open)', ifelse(lw_section == 'u1800', ' (U1800)', '')), ', Season ', s)`"
---

<style type="text/css">

h1.title {
  font-size: 28px;
}
h1 { /* Header 1 */
  font-size: 10px;
}
h2 { /* Header 2 */
    font-size: 10px;
}
h3 { /* Header 3 */
  font-size: 24px; 
}

h4 { /* Header 4 */
  font-size: 18px; 
}

h1, h2, h3, h4 {
  text-align: center;
}

h1, .h1, h2, .h2, h3, .h3, h4, .h4 {
    margin-top: 84px;
}

</style>



```{r, include = FALSE}
# Set default R chunk options for Rmd file
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# Load all required packages, incl. for functions
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, knitr, rio, kableExtra, gghighlight, data.table,
               ggrepel, ggridges, reactable, htmltools, httr, jsonlite, xml2, 
               rvest, ndjson, reshape2, utf8, lubridate, tictoc, cowplot, 
               tippy)

```


```{r}
# Source supporting functions
source("C:/Users/rahul/Documents/Github/rahulan-c.github.io/lichess4545-stats/scripts/all_functions.R", local = knitr::knit_global())

# Load supporting lookup data

# 1. Gambit openings - to enable analysis of gambits and gambit-lovers
gambits <- read.csv("C:/Users/rahul/Documents/Github/rahulan-c.github.io/lichess4545-stats/data/lookup/gambits.csv")

# 2. FIDE performance rating lookup values
# 2-column table with tournament performance scores and rating differences
# Compiled from https://handbook.fide.com/chapter/B022017
# Required for calculating player performance ratings using FIDE's method 
fide_tpr_lookup <- read.csv("C:/Users/rahul/Documents/Github/rahulan-c.github.io/lichess4545-stats/data/lookup/fide_tpr_lookup.csv")

# 3. Accounts banned from the Lichess4545 leagues
# Why? All games and pairings involving players banned by Lichess for ToS violations are removed before any stats are processed.
# Doesn't 
banned <- read.csv("C:/Users/rahul/Documents/Github/rahulan-c.github.io/lichess4545-stats/data/lookup/lichess4545_banned_players.csv")

```



```{r setup}
# Match user-defined document parameters to key variables, eg league, season, rounds, section etc.
league <- league
season <- s

# Get correct team_boards parameter
  if(league == "lonewolf"){team_boards <- 99} else
    if(season == 1){team_boards <- 4} else
      if(season == 2){team_boards <- 5} else
        if(season <= 15){team_boards <-  6} else 
          if(season <= 24){team_boards <-  8} else
            if(season <= 26){team_boards <-  10}

# Set rounds parameter correctly
# Maybe not necessary any more
# And maybe this would be better defined as a list of params for the 
# rmarkdown::render() command in the instareport() function. #foodforthought
if(league == "team4545"){rounds <- c(seq(1:8))}
if(league == "lonewolf"){
  if(season == 1) {rounds <- c(seq(1:5))}
  if(season %in% c(2:3)){rounds <- c(seq(1:8))}
  else{rounds <- c(seq(1:11))}
}

# LW U1800 choice
lw_u1800 <- ifelse(league == "lonewolf", ifelse(lw_section == "u1800", TRUE, FALSE), FALSE)

# Increment choice
# increment <- ifelse(league == "lonewolf", 30, ifelse(league == "team4545", 45, NA))


# Set league-specific colours to use in plots
lw_col <- "#699486"        #1c401c (darkest), #225622 (med), #699486 (lightest)
lw_col_dark <- "#225622"
team_col <- "#557f97"      #245164 (darkest), #3c687d (med) #557f97 (lightest)
team_col_dark <- "#245164"
league_col <- ifelse(league == "lonewolf", lw_col, team_col)               
league_col_dark <- ifelse(league == "lonewolf", lw_col_dark, team_col_dark)

# Define custom default reactable theme for tables
options(reactable.theme = reactableTheme(
    borderColor = "#dfe2e5",
    stripedColor = "#f6f8fa",
    highlightColor = "#f0f5f9",
    cellPadding = "8px 12px",
    # style = list(fontFamily = "-apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif"),
    searchInputStyle = list(width = "100%"),
    headerStyle = list(
      "&:hover[aria-sort]" = list(background = "hsl(0, 0%, 96%)"),
      "&[aria-sort='ascending'], &[aria-sort='descending']" = list(background = "hsl(0, 0%, 96%)"),
      borderColor = "#555"
    )
  )
)

```


```{r get_season_data, include = FALSE}
# Get data on season games, pairings and positions

league_load_label <- league
if(league == "lonewolf"){
  if(lw_u1800){league_load_label <- "lwu1800"} else {league_load_label <- "lwopen"}
}

# Load (tidied) games data
games <- readRDS(paste0("C:/Users/rahul/Documents/Github/rahulan-c.github.io/lichess4545-stats/data/games_", league_load_label, "_s", season, ".rds"))

# Load season pairings and positions data
pairings <- rio::import(paste0("C:/Users/rahul/Documents/Github/rahulan-c.github.io/lichess4545-stats/data/pairings_", league_load_label, "_s", season, ".csv"))
positions <- rio::import(paste0("C:/Users/rahul/Documents/Github/rahulan-c.github.io/lichess4545-stats/data/positions_", league_load_label, "_s", season, ".csv"))

# Final tidying of games data
# Add gambits data
games <- left_join(games, gambits, by = c("opening.name" = "gambit"))


# Fix all misprinted characters in character columns
games <- games %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã¼", "ü"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã¶", "ö"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã³", "ó"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã©", "é"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "â€¾", "‾"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "ãƒ„", "ツ"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "â€™", "'"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "’", "'")))


pairings <- pairings %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã¼", "ü"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã¶", "ö"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã³", "ó"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã©", "é"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "â€¾", "‾"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "ãƒ„", "ツ"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "â€™", "'"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "’", "'")))

positions <- positions %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã¼", "ü"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã¶", "ö"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã³", "ó"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "Ã©", "é"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "â€¾", "‾"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "ãƒ„", "ツ"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "â€™", "'"))) %>% 
  mutate(across(where(is.character), ~ str_replace_all(.x, "’", "'")))


```


```{r exclude_cheaters}
# Remove all games and pairings featuring players banned from the leagues for cheating

# Get list of players to exclude from data
cheat_reasons <- c("Marked as using computer assistance on lichess",
                   "Cheating alt and marked as engine on lichess",
                   "Admitted to using assistance during a 4545 game",
                   "Cheating alt / Multi accounting in the league / LW",
                   "Violated terms of service on lichess",
                   "Violated Lichess terms of service")

cheats <- banned %>% 
  filter(Reason %in% cheat_reasons) %>% 
  filter(Other.Notes != "mark reversed and readmitted") %>% 
  dplyr::pull(name)

games_incl_banned <- games
pairings_incl_banned <- pairings

# Exclude these players from the games data
games <- games %>% 
  filter(!(players.white.user.name %in% cheats)) %>% 
  filter(!(players.black.user.name %in% cheats)) %>% 
  filter(!(players.white.user.id %in% str_to_lower(cheats))) %>% 
  filter(!(players.black.user.id %in% str_to_lower(cheats)))

# Exclude from pairings data
pairings <- pairings %>% 
  filter(!(white %in% cheats)) %>% 
  filter(!(black %in% cheats)) %>% 
  filter(!(white %in% str_to_lower(cheats))) %>% 
  filter(!(black %in% str_to_lower(cheats)))

```

```{r}

# Identify whether there are valid move times in the games data.
# Since the earliest 4545/LW game with PGN clock times was played on 28 March 2017,
# we need to see if the most recent game in our dataset happened after this date. 
# If it did, we should assume that there are no valid movetimes in the games data, 
# and therefore not to present movetime-related stats and player awards.

movetimes_exist <- TRUE
if(max(games$started) <= lubridate::ymd("2017-03-28")){movetimes_exist <- FALSE}

no_movetimes_print <- "Not available for seasons that began before April 2018."

```


```{r echo=FALSE}
# Hide team-based stuff from LW reports
lw_hide <- FALSE
if(league != "team4545"){lw_hide <- TRUE}
```


### Overview


```{r season_dates}
# Get dates for first and last games
season_dates <- paste0(lubridate::day(min(games$started)), " ",
       lubridate::month(min(games$started), label = T), " ", 
       lubridate::year(max(games$started)),
       " to ",
       lubridate::day(max(games$started)), " ",
       lubridate::month(max(games$started), label = T), " ",
       lubridate::year(max(games$started)))

# Number of forfeited/unplayed games
forfeits <- pairings_incl_banned %>% 
  filter(winner == "forfeit/unplayed") %>% 
  nrow()

# White wins, draws and Black wins
wdl <- games %>% 
  group_by(result) %>% 
  tally() %>%
  mutate(perc = n/nrow(games))

games_w <- wdl %>% filter(result == "1-0") %>% dplyr::pull(n)
perc_w <- wdl %>% filter(result == "1-0") %>% dplyr::pull(perc)
games_b <- wdl %>% filter(result == "0-1") %>% dplyr::pull(n)
perc_b <- wdl %>% filter(result == "0-1") %>% dplyr::pull(perc)
games_d <- wdl %>% filter(result == "1/2-1/2") %>% dplyr::pull(n)
perc_d <- wdl %>% filter(result == "1/2-1/2") %>% dplyr::pull(perc)

# How games ended
ended <- games %>% 
  group_by(status) %>% 
  tally() %>% 
  mutate(status = replace(status, status == "outoftime", "out of time")) %>%
  mutate(status = replace(status, status == "stalemate", "stalemate")) %>%
  arrange(desc(n))

# Identify season summary URL
summary_url <- paste0("https://www.lichess4545.com/",
                        league, "/season/",
                        season, 
                        ifelse(lw_u1800, "u1800", ""),
                        "/summary/")

```

```{r}
# Plot wins by colour by board (4545) or rating band (LW)

if(league == "team4545"){
  
  wins_by_col <- games %>% 
      select(board, result) %>% 
      add_count(board, name = "n_board") %>% 
      add_count(board, result, name = "n_board_result") %>% 
      mutate(perc = n_board_result / n_board) %>% 
      distinct() %>% 
    mutate(cat = case_when(
      result == "1-0" ~ "cat1",
      result == "1/2-1/2" ~ "cat2",
      result == "0-1" ~ "cat3",
      TRUE ~ NA_character_
    )) %>%
    group_by(board) %>% 
    arrange(desc(cat)) %>% 
    # Get the % labels positioned right
    mutate(pos_label = ifelse(cat == "cat3",
                              # White wins
                              perc / 2, 
                              ifelse(cat == "cat2",
                                     # Draws
                                     lag(perc) + (perc/2), 
                                     ifelse(cat == "cat1",
                                            # Black wins
                                            lag(perc, 2) + lag(perc) + (perc/2), 
                                            0)))) %>% 
    ungroup()
    
    plt_wins_by_col <- ggplot(wins_by_col, aes(x = board, y = n_board_result, fill = cat)) +
      geom_bar(stat = "identity", position = "fill", colour = "#ffffff") +
      theme_cowplot() +
      scale_x_continuous(trans = "reverse", 
                         labels = paste0("B",as.character(wins_by_col$board)), 
                         breaks = wins_by_col$board) +
      scale_y_continuous(trans = "reverse", labels = scales::percent, breaks = waiver()) +
      geom_text(aes(y = pos_label, label = paste0(round(perc*100, 0), "%")), colour = "white") +
      labs(x = "", y = "") +
      theme(legend.justification = "centre",
            legend.position = "bottom",
            legend.title = element_blank(),
            axis.text.x = element_blank(),
            axis.ticks.x = element_blank(),
            axis.ticks.y = element_blank(),
            axis.line.x = element_blank(),
            axis.line.y = element_blank()) +
      scale_fill_manual(values = c("#b5b5b5", "#6c6c6c", "#383838"), 
                        labels = c("1-0", "1/2-1/2", "0-1")) +
      coord_flip()
  
} else {
  
  # LW plot
  
  # Make average ratings bins
  games$rating_group <- cut(games$mean_rating, 
                                breaks=c(800, 1000, 1200, 1400, 1600, 1800, 2000,
                                         2200, 2400, 2600),
                                labels = c("800-1000", "1000-1200",
                                           "1200-1400", "1400-1600", "1600-1800",
                                           "1800-2000", "2000-2200",
                                           "2200-2400", "2400-2600"),
                                include.lowest=TRUE, dig.lab = 4)
  
  wins_by_col <- games %>% 
      select(rating_group, result) %>% 
      add_count(rating_group, name = "n_group") %>% 
      add_count(rating_group, result, name = "n_group_result") %>% 
      mutate(perc = n_group_result / n_group) %>% 
      distinct() %>% 
    mutate(cat = case_when(
      result == "1-0" ~ "cat1",
      result == "1/2-1/2" ~ "cat2",
      result == "0-1" ~ "cat3",
      TRUE ~ NA_character_
    )) %>%
    group_by(rating_group) %>% 
    arrange(desc(cat)) %>% 
    # Get the % labels positioned right
    mutate(pos_label = ifelse(cat == "cat3",
                              # White wins
                              perc / 2, 
                              ifelse(cat == "cat2",
                                     # Draws
                                     lag(perc) + (perc/2), 
                                     ifelse(cat == "cat1",
                                            # Black wins
                                            lag(perc, 2) + lag(perc) + (perc/2), 
                                            0)))) %>% 
    ungroup()
    
    plt_wins_by_col <- ggplot(wins_by_col, aes(x = rating_group, y = n_group_result, fill = cat)) +
      geom_bar(stat = "identity", position = "fill", colour = "#ffffff") +
      theme_cowplot() +
      # scale_x_continuous(trans = "reverse", 
      #                    labels = paste0("B",as.character(wins_by_col$rating_group)), 
      #                    breaks = wins_by_col$rating_group) +
      scale_y_continuous(trans = "reverse", labels = scales::percent, breaks = waiver()) +
      geom_text(aes(y = pos_label, label = paste0(round(perc*100, 0), "%")), colour = "white") +
      labs(x = "", y = "") +
      theme(legend.justification = "centre",
            legend.position = "bottom",
            legend.title = element_blank(),
            axis.text.x = element_blank(),
            axis.ticks.x = element_blank(),
            axis.ticks.y = element_blank(),
            axis.line.x = element_blank(),
            axis.line.y = element_blank()) +
      scale_fill_manual(values = c("#b5b5b5", "#6c6c6c", "#383838"), 
                        labels = c("1-0", "1/2-1/2", "0-1")) +
      coord_flip()
  
}
```


<div class = "row">
  
<div class = "col-md-7">

<br>

- The `r paste0("[season]", "(", summary_url, ")")` ran from `r season_dates`.
- `r formatC(length(unique(c(unique(games$white), unique(games$black)))), big.mark = ",")` players took part, playing `r formatC(nrow(games), big.mark = ",")` games in total. `r formatC(forfeits, big.mark = ",")` games were either forfeited or set as scheduling draws.
- Across the season, White won `r formatC(games_w, big.mark=",")` games (`r round(perc_w*100, 1)`%), `r formatC(games_d, big.mark=",")` games (`r round(perc_d*100, 1)`%) were drawn, and Black won `r formatC(games_b, big.mark=",")` games (`r round(perc_b*100, 1)`%).
- `r formatC(ended$n[ended$status == "resign"], big.mark=",")` games ended with a resignation, `r formatC(ended$n[ended$status == "mate"], big.mark=",")` games by checkmate, `r formatC(ended$n[ended$status == "out of time"], big.mark=",")` games by time running out, and `r formatC(ended$n[ended$status == "stalemate"], big.mark=",")` games by stalemate.

</div>
  
<div class = "col-md-5">
<br>
```{r}
plt_wins_by_col
```
</div>
</div>

```{r}
# Identify top 3 teams (4545) or players (LW)

if(league == "team4545"){
  
  # For 4545...
  
  # 1st place team name
  first <- read_html(summary_url) %>% 
    html_element(".first-place .team-link") %>% 
    html_text()
  # 1st place team link
  first_link <- read_html(summary_url) %>% 
    html_element(".first-place .team-link") %>%
    html_attr("href")
  first_link <- paste0("https://www.lichess4545.com", first_link)
  # 1st place team players
  first_players <- read_html(summary_url) %>% 
    html_element(".first-place") %>% 
    html_text() %>% 
    str_replace_all("[\r\n]" , "") %>% 
    str_replace_all(first, "") %>% 
    str_squish()
  
  
  # 2nd place team name
  second <- read_html(summary_url) %>% 
    html_element(".second-place .team-link") %>% 
    html_text()
  # 2nd place team link
  second_link <- read_html(summary_url) %>% 
    html_element(".second-place .team-link") %>%
    html_attr("href")
  second_link <- paste0("https://www.lichess4545.com", second_link)
  # 2nd place team players
  second_players <- read_html(summary_url) %>% 
    html_element(".second-place") %>% 
    html_text() %>% 
    str_replace_all("[\r\n]" , "") %>% 
    str_replace_all(second, "") %>% 
    str_squish()
  
  # 3rd place team name
  third <- read_html(summary_url) %>% 
    html_element(".third-place .team-link") %>% 
    html_text()
  # 3rd place team link
  third_link <- read_html(summary_url) %>% 
    html_element(".third-place .team-link") %>%
    html_attr("href")
  third_link <- paste0("https://www.lichess4545.com", third_link)
  # 3rd place team players
  third_players <- read_html(summary_url) %>% 
    html_element(".third-place") %>% 
    html_text() %>% 
    str_replace_all("[\r\n]" , "") %>% 
    str_replace_all(third, "") %>% 
    str_squish()
  
  } else {
    
  # For LW
  
  # 1st place team
  first <- read_html(summary_url) %>% 
    html_element(".first-place .player-link") %>% 
    html_text()
  
  # Link to 1st place team profile
  first_link <- read_html(summary_url) %>% 
    html_element(".first-place .player-link") %>%
    html_attr("href")
  
  first_link <- paste0("https://www.lichess4545.com", first_link)
  
  # 2nd place
  second <- read_html(summary_url) %>% 
    html_element(".second-place .player-link") %>% 
    html_text()
  
  second_link <- read_html(summary_url) %>% 
    html_element(".second-place .player-link") %>%
    html_attr("href")
  
  second_link <- paste0("https://www.lichess4545.com", second_link)
  
  # 3rd place
  third <- read_html(summary_url) %>% 
    html_element(".third-place .player-link") %>% 
    html_text()
  
  third_link <- read_html(summary_url) %>% 
    html_element(".third-place .player-link") %>%
    html_attr("href")
  
  third_link <- paste0("https://www.lichess4545.com", third_link)
  
}

```


```{r, eval = ifelse(league == "team4545", TRUE, FALSE)}
# Produce table of all players for the top 3 teams in the final standings

# Identify top 3 teams
top_3 <- positions %>% 
  filter(round == max(positions$round)) %>% 
  filter(rank %in% c(1:3))

# Identify everyone who played for the top 3 teams
players_teams <- rbind(tibble("player" = games$white, "team" = games$team_w, "round" = games$round),
                       tibble("player" = games$black, "team" = games$team_b, "round" = games$round)) %>% 
  group_by(player, team) %>% 
  summarise(games = n()) %>% 
  arrange(desc(games))

players_gold <- players_teams %>% filter(team == top_3$team[top_3$rank == 1]) %>% arrange(desc(games)) %>% dplyr::pull(player)
players_silver <- players_teams %>% filter(team == top_3$team[top_3$rank == 2]) %>% arrange(desc(games)) %>% dplyr::pull(player)
players_bronze <- players_teams %>% filter(team == top_3$team[top_3$rank == 3]) %>% arrange(desc(games)) %>% dplyr::pull(player)

# Identify length of longest team list
longest_team <- max(c(length(players_gold), 
                      length(players_silver), 
                      length(players_bronze)))

players_gold <- sort(players_gold)
if(length(players_gold) < longest_team){
  players_gold <- c(players_gold, rep("", longest_team - length(players_gold)))
}

players_silver <- sort(players_silver)
if(length(players_silver) < longest_team){
  players_silver <- c(players_silver, rep("", longest_team - length(players_silver)))
}

players_bronze <- sort(players_bronze)
if(length(players_bronze) < longest_team){
  players_bronze <- c(players_bronze, rep("", longest_team - length(players_bronze)))
}

# Create final table of players
winners <- tibble("Gold" = players_gold,
                  "Silver" = players_silver,
                  "Bronze" = players_bronze)
```


<!-- A different approach, based on https://holtzy.github.io/Pimp-my-rmd/#several_columns -->

<div class = "row">
  
<div class = "col-md-4">

:::first
<p style="font-size:12pt; font-weight: 900;">
1st place
<br>
</p>
<p style="font-size:16pt; font-weight: 900;">
    `r paste0("[", first, "]", "(", first_link, ")")`
</p>
<p style="font-size:12pt; font-weight: 900;">
</p>
:::

</div>
  
<div class = "col-md-4">

:::second
<p style="font-size:12pt; font-weight: 900;">
2nd place
<br>
</p>
<p style="font-size:14pt; font-weight: 600;">
    `r paste0("[", second, "]", "(", second_link, ")")`
</p>
<p style="font-size:12pt; font-weight: 900;">
</p>
:::

</div>

<div class = "col-md-4">

:::third
<p style="font-size:12pt; font-weight: 900;">
3rd place
<br>
</p>
<p style="font-size:14pt; font-weight: 600;">
    `r paste0("[", third, "]", "(", third_link, ")")`
</p>
<p style="font-size:12pt; font-weight: 900;">
</p>
:::

</div>

</div>

```{r, eval = ifelse(league == "team4545", TRUE, FALSE)}
# Show 4545 podium team players in a reactable table
reactable(winners,
          fullWidth = TRUE,
          resizable = FALSE,
          compact = TRUE,
          pagination = FALSE,
          outlined = FALSE,
          borderless = TRUE,
          columns = list(
            Gold = colDef(header = NULL, align = "center", minWidth = 250,
                          style = list(background = "#fff2b1")),
            Silver = colDef(header = NULL, align = "center", minWidth = 250),
            Bronze = colDef(header = NULL, align = "center", minWidth = 250)))
```

#### Story of the season

```{r position_tracker, out.width="90%", fig.align="center"}
# Team/player position tracker

if(league == "team4545"){
  
top_places <- positions %>% 
  filter(round == 8) %>% 
  arrange(rank) %>% 
  filter(rank <= 5) %>% 
  dplyr::pull(team)
  
position_tracker <- positions %>% 
  mutate(round = as.factor(round)) %>% 
  ggplot(aes(x = round, y = rank, colour = team)) +
  geom_line(aes(group = team), size = 2) +
  # geom_point(aes(group = team), size = 2) +
  theme_minimal() +
  # scale_y_reverse(limits = c(20, 1), breaks = integer_breaks()) +
  scale_y_reverse(limits = c(max(positions$rank), 1), breaks = c(max(positions$rank), 1)) +
  scale_x_discrete(expand = expansion(add = c(0.5, 0.5))) +
  scale_color_manual(values = c("#ffd700", "#c0c0c0", "#cd7f32", "#b2cefe", "#b2cefe"),
                       breaks = c(top_places),
                       labels = c(top_places)) +
  gghighlight::gghighlight(team %in% top_places, use_direct_label = T,
                             unhighlighted_params = list(colour = alpha("grey", 0.1)),
                             label_params = list(size = 4, 
                                                 nudge_x = -1, 
                                                 nudge_y = -15, 
                                                 direction = "y",
                                                 fill = "white",
                                                 colour = "black")) +
  labs(x = "Round",
       y = "Rank after each round") +
  theme(legend.position = "right")
  
position_tracker

}

if(league == "lonewolf"){
  
  top_places <- positions %>% 
    filter(round == 12) %>% 
    arrange(pos) %>% 
    filter(pos <= 3) %>%  
    dplyr::pull(player)
  
  position_tracker <- positions %>% 
    filter(!(is.na(pos))) %>% 
    mutate(player = str_to_lower(player)) %>% 
    mutate(round = as.factor(round)) %>% 
    ggplot(aes(x = round, y = pos, colour = player)) +
    geom_line(aes(group = player), size = 2) +
    # geom_point(aes(group = player), size = 2) +
    theme_minimal() +
    scale_y_reverse(limits = c(50, 1), breaks = integer_breaks()) +
    scale_x_discrete(expand = expansion(add = c(0, 2))) +
    gghighlight::gghighlight(player %in% top_places, use_direct_label = T,
                             unhighlighted_params = list(colour = alpha("grey", 0.1)),
                             label_params = list(size = 4, nudge_x = 2, nudge_y = 0, direction = "y")) +
    labs(x = "Round",
         y = "Rank before round") +
    theme(legend.position = "right") +
    scale_color_manual(values = c("#ffd700", "#c0c0c0", "#cd7f32"),
                       breaks = c(top_places),
                       labels = c(top_places))

  position_tracker

}



```



```{r results='asis', echo=FALSE}
# Hide board perfs tables from LW reports
if(lw_hide){cat("<!---")}
```

#### Top of the boards

```{r bperfs, eval = ifelse(league == "team4545", TRUE, FALSE)}
# Board perf ratings


bperfs_w <- pairings %>% 
  filter(winner != "forfeit/unplayed") %>% 
  group_by(white, board) %>%
  summarise(sum_opp_rating = sum(rating_b),
            games = n(),
            points = ((sum(winner == "white") * 1) + (sum(winner == "draw") * 0.5)),
            wins = sum(winner == "white"),
            draws = sum(winner == "draw"),
            losses = sum(winner == "black"),
            initial_rating = rating_w[which.min(round)],
            initial_round = min(round)) %>% 
  rename("player" = white)

bperfs_b <- pairings %>% 
  filter(winner != "forfeit/unplayed") %>% 
  group_by(black, board) %>%
  summarise(sum_opp_rating = sum(rating_w),
            games = n(),
            points = ((sum(winner == "black") * 1) + (sum(winner == "draw") * 0.5)),
            wins = sum(winner == "black"),
            draws = sum(winner == "draw"),
            losses = sum(winner == "white"),
            initial_rating = rating_b[which.min(round)],
            initial_round = min(round)) %>% 
  rename("player" = black)

bperfs <- rbind(bperfs_w, bperfs_b)
rm(bperfs_w, bperfs_b)

# Compute board performance ratings using FIDE method
# Create list with board-specific rankings
bperfs <- bperfs %>% 
  group_by(player, board) %>% 
  summarise(sum_opp_rating = sum(sum_opp_rating),
            games = sum(games),
            avg_opp_rating = sum_opp_rating / games,
            points = sum(points),
            tp_score = points / games,
            wins = sum(wins),
            draws = sum(draws),
            losses = sum(losses),
            initial_rating = initial_rating[which.min(initial_round)]) %>%
  mutate(adj = fide_tpr_lookup[match(round(tp_score, 2), fide_tpr_lookup$p),2]) %>% 
  mutate(bperf_rating = avg_opp_rating + adj) %>% 
  mutate(bperf_diff = bperf_rating - initial_rating) %>% 
  filter(games >= 4) %>%
  ungroup() %>% 
  group_by(board) %>% 
  arrange(desc(bperf_rating)) %>% 
  slice_max(order_by = bperf_rating, n = 5) %>% 
  select(board, player, games, points, bperf_rating)

# Show board rankings in a table
tbl_bperfs <- reactable(bperfs, groupBy = "board",
          fullWidth = TRUE,
          resizable = TRUE,
          compact = T,
          columns = list(
            board = colDef(name = "Board",
                          align = "center",
                          minWidth = 100),
            player = colDef(name = "Player",
                           minWidth = 200),
            games = colDef(name = "Games", minWidth = 75, align = "center"),
            points = colDef(name = "Points", minWidth =  75, align = "center"),
            bperf_rating = colDef(name = "Board Perf.", minWidth = 100, 
                                  align = "center",
                                  format = colFormat(digits = 0))
          )
          )
tbl_bperfs

```

```{r results='asis', echo=FALSE}
# Stop hiding stuff from LW reports
if(lw_hide){cat("-->")}
```


### Summary charts and tables {.tabset .tabset-fade .tabset-pills}

```{r results='asis', echo=FALSE}
# Hide match results tab from LW reports
if (lw_hide) {cat("<!---")}
```

```{r results='asis', echo=FALSE}
# Stop hiding stuff from LW reports
if (lw_hide) {cat("-->")}
```

#### When were games played?

```{r games_by_day, fig.show="hold", out.width = "50%"}

# Create summary table with info for heatmap
games_by_day_time <- plyr::ddply(games, c("hour", "wday"),
                             summarise,
                             N = length(started))
# Reverse order of months
games_by_day_time$wday <- factor(games_by_day_time$wday, levels=rev(levels(games_by_day_time$wday)))

# Make bar chart of games per day
plt_gamesbyday <- games_by_day_time %>% 
  group_by(wday) %>% 
  tally(N) %>% 
  mutate(wday = fct_relevel(wday, 
                            "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")) %>% 
  ggplot(aes(wday, n)) +
  geom_col(fill = league_col, colour = league_col) +
  geom_text(aes(label = n), colour = "white", size = 5, vjust = 1.5) +
  theme_minimal() +
  labs(x = "Day", y = "Games", 
       subtitle = paste0(round((sum(games_by_day_time[games_by_day_time$wday %in% c("Sat", "Sun"), ]$N) / nrow(games)) * 100, 0),
                         "% played on weekend")) +
  scale_y_continuous(breaks = integer_breaks()) +
  theme(axis.text.x = element_text(size = 12)) +
  theme(plot.title = element_text(size = 10, hjust = 0.5)) +
  theme(plot.subtitle = element_text(size = 10))
plt_gamesbyday

# Make heatmap
heat_dayhour <- ggplot(games_by_day_time, aes(hour, wday)) + geom_tile(aes(fill = N),colour = "white", na.rm = TRUE) +
  scale_fill_gradient(low = "white", high = league_col) +
  guides(fill=guide_legend(title="# games")) +
  theme_bw() + theme_minimal() +
  labs(x = "Hour (UTC)", y = "Day") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
heat_dayhour

```

#### How long did games take?

```{r hists, fig.show="hold", out.width = "50%"}
# Number of moves histogram
moves_hist <- games %>% 
  ggplot(aes(num_moves)) +
  geom_histogram(binwidth = 5, fill = league_col, col = "white") +
  theme_minimal() +
  geom_vline(xintercept = mean(games$num_moves), size = 1, colour="#333333", linetype = "dashed") +
  scale_y_continuous(breaks = integer_breaks()) +
  labs(subtitle = paste0("Average moves/game: ", round(mean(games$num_moves), 1)),
       x = "# moves", y = "Games")

# Game duration histogram
duration_hist <- games %>% 
  ggplot(aes(duration/60)) +
  geom_histogram(binwidth = 15, fill = league_col, col = "white") +
  theme_minimal() +
  geom_vline(xintercept = mean(games$duration/60), size = 1, colour="#333333", linetype = "dashed") +
  labs(x = "Minutes", y = "Games",
       subtitle = paste0("Average time taken/game: ", round(mean(games$duration/60), 1), " minutes")) +
  scale_y_continuous(breaks = integer_breaks())

moves_hist
duration_hist
```

#### Longest games (moves)

*Includes games ranked at or above the 90th percentile by number of moves.*

```{r longest_moves}
# Longest games (by # moves)

longest_moves <- games %>% 
  arrange(desc(num_moves)) %>% 
  select("white" = players.white.user.name, 
         "black" = players.black.user.name, 
         id, 
         num_moves,
         started) %>% 
  mutate(players = paste0(white, " - ", black),
         url = paste0("https://lichess.org/", id),
         rank = dense_rank(num_moves)) %>% 
  select(rank, players, started, url, num_moves) %>% 
  mutate(date = sprintf('%s %2d %2s %2d', lubridate::wday(started, label=T, abbr=T), lubridate::day(started), lubridate::month(started, label = T, abbr = T), lubridate::year(started))) %>% 
  mutate(prank = ntile(num_moves, 100)) %>% # calculate percentiles
  filter(prank >= 90) %>%  # only show games above 75th percentile
  select(-c(prank, started)) %>% 
  select(rank, players, date, url, num_moves)

reactable(longest_moves,
          pagination = TRUE,
          searchable = TRUE,
          fullWidth = FALSE,
          resizable = TRUE,
          compact = T,
          columns = list(
            rank = colDef(name = "Rank",
                          align = "center",
                          minWidth = 50),
          players = colDef(name = "Players / Link",
                           minWidth = 300,
                           html = TRUE, 
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', longest_moves$url[index], value)
          }),
          date = colDef(name = "Date",
                        minWidth = 140),
          url = colDef(name = "URL",
                       show = FALSE),
          num_moves = colDef(name = "Moves",
                                  minWidth = 100)
          )
          )



```

#### Longest games

*Includes games ranked at or above the 90th percentile by total time.*

```{r longest_time}
# Longest games (by duration)
# only show top 25%
# cols: rank, players (w/ url), date, time taken

longest_duration <- games %>% 
  arrange(desc(duration)) %>% 
  select("white" = players.white.user.name, 
         "black" = players.black.user.name, 
         id, 
         duration,
         started) %>% 
  mutate(players = paste0(white, " - ", black),
         url = paste0("https://lichess.org/", id),
         rank = dense_rank(desc(duration))) %>% 
  select(rank, players, started, url, duration) %>% 
  mutate(duration = lubridate::seconds_to_period(duration)) %>%
  mutate(duration_print = sprintf('%2gh %2gm %.0fs', lubridate::hour(duration), lubridate::minute(duration), lubridate::second(duration))) %>% # more readable total times
  mutate(date = sprintf('%s %2d %2s %2d', lubridate::wday(started, label=T, abbr=T), lubridate::day(started), lubridate::month(started, label = T, abbr = T), lubridate::year(started))) %>% 
  mutate(prank = ntile(duration, 100)) %>% # calculate percentiles
  filter(prank >= 90) %>%  # only show games above certain percentile
  select(rank, players, date, url, duration_print)

reactable(longest_duration,
          pagination = TRUE,
          searchable = TRUE,
          fullWidth = FALSE,
          resizable = TRUE,
          compact = T,
          columns = list(
            rank = colDef(name = "Rank",
                          align = "center",
                          minWidth = 50),
          players = colDef(name = "Players / Link",
                           minWidth = 300,
                           html = TRUE, 
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', longest_duration$url[index], value)
          }),
          date = colDef(name = "Date",
                        minWidth = 140),
          url = colDef(name = "URL",
                       show = FALSE),
          duration_print = colDef(name = "Total time",
                                  minWidth = 100)
          )
          )

```

### Stats by board / rating band {.tabset .tabset-fade .tabset-pills}

#### ACPL

```{r acpl_by_board, fig.out = "75%", eval = ifelse(league == "team4545", TRUE, FALSE)}
# Plot ACPL by board

# Compute errors by board
error_rates_w <- games %>% 
  select(white, board, num_moves, 
         players.white.analysis.blunder, players.white.analysis.mistake, players.white.analysis.inaccuracy, players.white.analysis.acpl,
         players.black.analysis.blunder, players.black.analysis.mistake, players.black.analysis.inaccuracy, players.black.analysis.acpl)

error_rates_b <- games %>% 
  select(black, board, num_moves, 
         players.black.analysis.blunder, players.black.analysis.mistake, players.black.analysis.inaccuracy, players.black.analysis.acpl,
         players.white.analysis.blunder, players.white.analysis.mistake, players.white.analysis.inaccuracy, players.white.analysis.acpl)

colnames(error_rates_w) <- c("player", "board", "moves", "blunders", "mistakes", "inaccuracies", "acpl",
                             "opp_blunders", "opp_mistakes", "opp_inaccuracies", "opp_acpl")
colnames(error_rates_b) <- c("player", "board", "moves", "blunders", "mistakes", "inaccuracies", "acpl",
                             "opp_blunders", "opp_mistakes", "opp_inaccuracies", "opp_acpl")

error_rates <- rbind(error_rates_w, error_rates_b)
rm(error_rates_w, error_rates_b)

error_rates <- error_rates %>% 
  mutate(cpl = acpl * moves,
         opp_cpl = opp_acpl * moves)

error_rates_grouped <- error_rates %>% 
  group_by(board) %>% 
  summarise(games = n(),
            blunder_rate = sum(blunders, na.rm = T) / sum(moves, na.rm = T),
            mistake_rate = sum(mistakes, na.rm = T) / sum(moves, na.rm = T),
            inaccuracy_rate = sum(inaccuracies, na.rm = T) / sum(moves, na.rm = T),
            error_rate = blunder_rate + mistake_rate + inaccuracy_rate,
            acpl = sum(cpl, na.rm = T) / sum(moves, na.rm = T)) %>% 
  mutate(blunder_rate = round(blunder_rate * 100, 1),
         error_rate = round(error_rate * 100, 1),
         acpl = round(acpl, 1)) %>% 
  select(board, games, acpl, blunder_rate) %>% 
  arrange(board)

# Plot ACPL by board
plot_acpl_by_board <- ggplot(error_rates_grouped, aes(x = board, y = acpl)) +
  geom_line(col = "darkblue") +
  geom_point(col = "darkblue") +
  geom_text_repel(label = error_rates_grouped$acpl, col = "darkblue") +
  theme_minimal() +
  scale_x_continuous(labels = paste0("B",as.character(error_rates_grouped$board)), 
                     breaks = error_rates_grouped$board) +
  labs(x = "Board", y = "ACPL",
       title = "ACPL by board") +
  theme_cowplot()

plot_acpl_by_board
```


```{r error_rates_by_rating_band, eval = ifelse(league == "team4545", FALSE, TRUE), fig.align="center"}
# Calculate error rates for summary stats

# Plot errors by rating band
error_rates_w <- games %>% 
  select(white, rating_w, num_moves, 
         players.white.analysis.blunder, players.white.analysis.mistake, players.white.analysis.inaccuracy, players.white.analysis.acpl,
         players.black.analysis.blunder, players.black.analysis.mistake, players.black.analysis.inaccuracy, players.black.analysis.acpl)

error_rates_b <- games %>% 
  select(black, rating_b, num_moves, 
         players.black.analysis.blunder, players.black.analysis.mistake, players.black.analysis.inaccuracy, players.black.analysis.acpl,
         players.white.analysis.blunder, players.white.analysis.mistake, players.white.analysis.inaccuracy, players.white.analysis.acpl)

colnames(error_rates_w) <- c("player", "rating", "moves", "blunders", "mistakes", "inaccuracies", "acpl",
                             "opp_blunders", "opp_mistakes", "opp_inaccuracies", "opp_acpl")
colnames(error_rates_b) <- c("player", "rating", "moves", "blunders", "mistakes", "inaccuracies", "acpl",
                             "opp_blunders", "opp_mistakes", "opp_inaccuracies", "opp_acpl")

error_rates <- rbind(error_rates_w, error_rates_b)
rm(error_rates_w, error_rates_b)

error_rates <- error_rates %>% 
  mutate(cpl = acpl * moves,
         opp_cpl = opp_acpl * moves)

error_rates$rating_group <- cut(error_rates$rating, 
                                breaks=c(800, 1000, 1200, 1400, 1600, 1800, 2000,
                                         2200, 2400, 2600),
                                labels = c("800-1000", "1000-1200",
                                           "1200-1400", "1400-1600", "1600-1800",
                                           "1800-2000", "2000-2200",
                                           "2200-2400", "2400-2600"),
                                include.lowest=TRUE, dig.lab = 4)

error_rates_grouped <- error_rates %>% 
  group_by(rating_group) %>% 
  summarise(games = n(),
            blunder_rate = sum(blunders, na.rm = T) / sum(moves, na.rm = T),
            mistake_rate = sum(mistakes, na.rm = T) / sum(moves, na.rm = T),
            inaccuracy_rate = sum(inaccuracies, na.rm = T) / sum(moves, na.rm = T),
            error_rate = blunder_rate + mistake_rate + inaccuracy_rate,
            acpl = sum(cpl, na.rm = T) / sum(moves, na.rm = T)) %>% 
  mutate(blunder_rate = round(blunder_rate * 100, 1),
         error_rate = round(error_rate * 100, 1),
         acpl = round(acpl, 1)) %>% 
  select(rating_group, games, blunder_rate, error_rate, acpl) %>% 
  arrange(desc(rating_group))

error_rates_grouped %>% 
  kable(caption = "Error rates by rating band",
        col.names = c("Rating band", "Games","Blunder rate", "Total error rate", "ACPL")) %>% 
  kableExtra::kable_classic(full_width = F, html_font = "arial", position = "left")


```



#### Games with lowest combined ACPL

The games with the lowest combined ACPL (including draws).


```{r lowest_acpl_games}

if(league == "team4545"){
# Show games with lowest combined ACPL by board
lowest_acpl_games_all <- games %>% 
  filter(!(is.na(board))) %>% 
  select(id, board, white, black, players.white.analysis.acpl, players.black.analysis.acpl, result, started) %>% 
  mutate(sum_acpl = players.white.analysis.acpl + players.black.analysis.acpl,
         url = paste0("https://lichess.org/", id),
         players = paste0(white, " - ", black)) %>%
  mutate(date = sprintf('%s %2d %2s %2d', lubridate::wday(started, label=T, abbr=T), lubridate::day(started), lubridate::month(started, label = T, abbr = T), lubridate::year(started))) %>% 
  select(board, players, url, result, sum_acpl, date) %>% 
  group_by(board) %>% 
  slice_min(sum_acpl) 

reactable(lowest_acpl_games_all,
          pagination = FALSE,
          searchable = FALSE,
          fullWidth = TRUE,
          resizable = TRUE,
          compact = T,
          columns = list(
          board = colDef(name = "Board", align = "center", minWidth = 70),
          date = colDef(name = "Date", minWidth = 140),
          players = colDef(name = "Players / Link",
                           minWidth = 250,
                           html = TRUE,
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', lowest_acpl_games_all$url[index], value)
          }),
          url = colDef(show = FALSE),
          result = colDef(name = "Result", align = "center"),
          sum_acpl = colDef(name = "Sum ACPL", align = "center")
          )
)
}

if(league == "lonewolf"){
# Show games with lowest combined ACPL by board
lowest_acpl_games_all <- games %>% 
  select(id, white, black, players.white.analysis.acpl, players.black.analysis.acpl, result, started) %>% 
  mutate(sum_acpl = players.white.analysis.acpl + players.black.analysis.acpl,
         url = paste0("https://lichess.org/", id),
         players = paste0(white, " - ", black)) %>%
  mutate(date = sprintf('%s %2d %2s %2d', lubridate::wday(started, label=T, abbr=T), lubridate::day(started), lubridate::month(started, label = T, abbr = T), lubridate::year(started))) %>% 
  select(players, url, result, sum_acpl, date) %>% 
  slice_min(sum_acpl, n = 10) %>% 
  arrange(sum_acpl)

reactable(lowest_acpl_games_all,
          pagination = FALSE,
          searchable = FALSE,
          fullWidth = TRUE,
          resizable = TRUE,
          compact = T,
          columns = list(
          date = colDef(name = "Date", minWidth = 140),
          players = colDef(name = "Players / Link",
                           minWidth = 250,
                           html = TRUE,
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', lowest_acpl_games_all$url[index], value)
          }),
          url = colDef(show = FALSE),
          result = colDef(name = "Result", align = "center"),
          sum_acpl = colDef(name = "Sum ACPL", align = "center")
          )
)
}


```

#### Excl. draws

The *decisive* games with the lowest combined ACPL.

```{r}
# Show same but for decisive games

if(league == "team4545"){
lowest_acpl_games_decisive <- games %>% 
  filter(!(is.na(board))) %>% 
  filter(winner %in% c("white", "black")) %>% 
  select(id, board, white, black, players.white.analysis.acpl, players.black.analysis.acpl, result, started) %>% 
  mutate(sum_acpl = players.white.analysis.acpl + players.black.analysis.acpl,
         url = paste0("https://lichess.org/", id),
         players = paste0(white, " - ", black)) %>%
  mutate(date = sprintf('%s %2d %2s %2d', lubridate::wday(started, label=T, abbr=T), lubridate::day(started), lubridate::month(started, label = T, abbr = T), lubridate::year(started))) %>% 
  select(board, players, url, result, sum_acpl, date) %>% 
  group_by(board) %>% 
  slice_min(sum_acpl) 

reactable(lowest_acpl_games_decisive,
          pagination = FALSE,
          searchable = FALSE,
          fullWidth = TRUE,
          resizable = TRUE,
          compact = T,
          columns = list(
          board = colDef(name = "Board", align = "center", minWidth = 70),
          date = colDef(name = "Date", minWidth = 140),
          players = colDef(name = "Players / Link",
                           minWidth = 250,
                           html = TRUE,
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', lowest_acpl_games_decisive$url[index], value)
          }),
          url = colDef(show = FALSE),
          result = colDef(name = "Result", align = "center"),
          sum_acpl = colDef(name = "Sum ACPL", align = "center")
          ))
}

if(league == "lonewolf"){
lowest_acpl_games_decisive <- games %>% 
  filter(winner %in% c("white", "black")) %>% 
  select(id, white, black, players.white.analysis.acpl, players.black.analysis.acpl, result, started) %>% 
  mutate(sum_acpl = players.white.analysis.acpl + players.black.analysis.acpl,
         url = paste0("https://lichess.org/", id),
         players = paste0(white, " - ", black)) %>%
  mutate(date = sprintf('%s %2d %2s %2d', lubridate::wday(started, label=T, abbr=T), lubridate::day(started), lubridate::month(started, label = T, abbr = T), lubridate::year(started))) %>% 
  select(players, url, result, sum_acpl, date) %>% 
  slice_min(sum_acpl, n = 10) %>% 
  arrange(sum_acpl)

reactable(lowest_acpl_games_decisive,
          pagination = FALSE,
          searchable = FALSE,
          fullWidth = TRUE,
          resizable = TRUE,
          compact = T,
          columns = list(
          date = colDef(name = "Date", minWidth = 140),
          players = colDef(name = "Players / Link",
                           minWidth = 250,
                           html = TRUE,
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', lowest_acpl_games_decisive$url[index], value)
          }),
          url = colDef(show = FALSE),
          result = colDef(name = "Result", align = "center"),
          sum_acpl = colDef(name = "Sum ACPL", align = "center")
          ))
}

```

### Openings - tables {.tabset .tabset-fade .tabset-pills}



#### Popular openings

All openings played in the season, excluding variations.

```{r}
# Show openings by broad opening name (excl. variation)
openings_exclvar <- games %>% 
  group_by(opening.broad) %>% 
  summarise(games = n(),
            mean_rating = mean(mean_rating),
            score_w = sum(score_w),
            white_wins = (sum(result == "1-0") / games) * 100,
            draws = (sum(result == "1/2-1/2") / games) * 100,
            black_wins = (sum(result == "0-1") / games) * 100,
            mean_eval_after_15 = mean(eval_after_15, na.rm = T) / 100) %>% 
  arrange(desc(games)) %>% 
  mutate(rank = dense_rank(desc(games))) %>% 
  mutate(perc_w = (score_w / games) * 100) %>%
  select(rank, opening.broad, games, perc_w, white_wins, draws, black_wins, 
         mean_eval_after_15, mean_rating)

reactable(openings_exclvar,
          pagination = TRUE, 
          fullWidth = TRUE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "Rank", minWidth = 70, align = "center"),
    opening.broad = colDef(name = "Opening", minWidth = 200),
    games = colDef(name = "Games", minWidth = 100, align = "center"),
    perc_w = colDef(name = "White %", minWidth = 100, align = "center", format = colFormat(digits = 0)),
    white_wins = colDef(name = "1-0 %", minWidth = 100, align = "center", format = colFormat(digits = 0)),
    draws = colDef(name = "Draw %", minWidth = 100, align = "center", format = colFormat(digits = 0)),
    black_wins = colDef(name = "0-1 %", minWidth = 100, align = "center", format = colFormat(digits = 0)),
    mean_eval_after_15 = colDef(name = "Mean Eval", minWidth = 100, align = "center", format = colFormat(digits = 2)),
    mean_rating = colDef(name = "Avg Rating", minWidth = 100, align = "center", format = colFormat(digits = 0))),
    compact = T)
```


#### Popular variations

All openings played in the season, including variations.

```{r}
# Show openings by Lichess-determined opening name including variation
openings_inclvar <- games %>% 
  group_by(opening.name) %>% 
  summarise(games = n(),
            mean_rating = mean(mean_rating),
            score_w = sum(score_w),
            white_wins = (sum(result == "1-0") / games) * 100,
            draws = (sum(result == "1/2-1/2") / games) * 100,
            black_wins = (sum(result == "0-1") / games) * 100,
            mean_eval_after_15 = mean(eval_after_15, na.rm = T) / 100) %>% 
  arrange(desc(games)) %>% 
  mutate(rank = dense_rank(desc(games))) %>% 
  mutate(perc_w = (score_w / games)*100) %>%
  select(rank, opening.name, games, perc_w, white_wins, draws, black_wins, 
         mean_eval_after_15, mean_rating)

reactable(openings_inclvar,
          pagination = TRUE, 
          fullWidth = TRUE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center", footer = "Total"),
    opening.name = colDef(name = "Opening", minWidth = 300),
    games = colDef(name = "Games", minWidth = 100, align = "center"),
    perc_w = colDef(name = "White %", minWidth = 100, align = "center", format = colFormat(digits = 0)),
    white_wins = colDef(name = "1-0 %", minWidth = 100, align = "center", format = colFormat(digits = 0)),
    draws = colDef(name = "Draw %", minWidth = 100, align = "center", format = colFormat(digits = 0)),
    black_wins = colDef(name = "0-1 %", minWidth = 100, align = "center", format = colFormat(digits = 0)),
    mean_eval_after_15 = colDef(name = "Mean Eval", minWidth = 100, align = "center", format = colFormat(digits = 2)),
    mean_rating = colDef(name = "Avg Rating", minWidth = 100, align = "center", 
                         format = colFormat(digits = 0))),
    defaultColDef = colDef(footerStyle = list(fontWeight = "bold")),
    compact = T)
```



#### Best for White

The best-scoring main openings for White. 

*Includes all main openings played in at least 10 games.* 

```{r}
# Same as (3) but ordered by White score instead
openings_bestwhite <- games %>% 
  group_by(opening.broad) %>% 
  summarise(games = n(),
            mean_rating = mean(mean_rating),
            score_w = sum(score_w),
            white_wins = (sum(result == "1-0") / games) * 100,
            draws = (sum(result == "1/2-1/2") / games) * 100,
            black_wins = (sum(result == "0-1") / games) * 100,
            mean_eval_after_15 = mean(eval_after_15, na.rm = T) / 100) %>% 
  mutate(perc_w = (score_w / games) * 100) %>%
  arrange(desc(perc_w)) %>% 
  filter(games > 10) %>% 
  mutate(rank = desc_rank(desc(perc_w))) %>% 
  select(rank, opening.broad, games, perc_w, white_wins, draws, black_wins,
         mean_eval_after_15, mean_rating)

reactable(openings_bestwhite,
          pagination = TRUE, 
          fullWidth = TRUE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center"),
    opening.broad = colDef(name = "Opening", minWidth = 200),
    games = colDef(name = "Games"),
    perc_w = colDef(name = "White's score (%)", format = colFormat(digits = 0)),
    white_wins = colDef(name = "White wins (%)", format = colFormat(digits = 0)),
    draws = colDef(name = "Draws (%)", format = colFormat(digits = 0)),
    black_wins = colDef(name = "Black wins (%)", format = colFormat(digits = 0)),
    mean_eval_after_15 = colDef(name = "Mean eval after 15 moves", format = colFormat(digits = 2)),
    mean_rating = colDef(name = "Avg rating", format = colFormat(digits = 0))),
    compact = T)

```

#### Best for Black

The best-scoring main openings for Black. 

*Includes all main openings played in at least 10 games.* 

```{r openings_for_black}
# Same ordered by Black score
openings_bestblack <- games %>% 
  group_by(opening.broad) %>% 
  summarise(games = n(),
            mean_rating = mean(mean_rating),
            score_b = sum(score_b),
            white_wins = (sum(result == "1-0") / games) * 100,
            draws = (sum(result == "1/2-1/2") / games) * 100,
            black_wins = (sum(result == "0-1") / games) * 100,
            mean_eval_after_15 = mean(eval_after_15, na.rm = T) / 100) %>% 
  mutate(perc_b = (score_b / games)*100) %>% 
  arrange(desc(perc_b)) %>% 
  filter(games > 10) %>% 
  mutate(rank = dense_rank(desc(perc_b))) %>% 
  select(rank, opening.broad, games, perc_b, black_wins, draws, white_wins, 
         mean_eval_after_15, mean_rating)

reactable(openings_bestblack,
          pagination = TRUE, 
          fullWidth = TRUE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center"),
    opening.broad = colDef(name = "Opening", minWidth = 200),
    games = colDef(name = "Games"),
    perc_b = colDef(name = "Black's score (%)", format = colFormat(digits = 0)),
    white_wins = colDef(name = "White wins (%)", format = colFormat(digits = 0)),
    draws = colDef(name = "Draws (%)", format = colFormat(digits = 0)),
    black_wins = colDef(name = "Black wins (%)", format = colFormat(digits = 0)),
    mean_eval_after_15 = colDef(name = "Mean eval after 15 moves", format = colFormat(digits = 2)),
    mean_rating = colDef(name = "Avg rating", format = colFormat(digits = 0))),
    compact = T)

```

#### Popular gambits

All gambit openings played in the season.



```{r}
# Show gambits played

# Identify games with gambits
gambits <- games %>%
  filter(gambit_col %in% c("white", "black")) %>% 
  mutate(gambit_name = rep(NA, nrow(.)))

# Add gambit names to data

# Iterating through each game in the gambits dataset...
for(i in seq(1:nrow(gambits))){
  test <- gambits$opening.name[i]
  # First check if there's a colon in the opening name
  if(str_detect(test, ":")){
    # If there is, and it appears before "Gambit", extract the substring between the two, including "Gambit"
    if(str_locate(test, ":")[1,1] < str_locate(test, "Gambit")[1,1]){
      result <- str_extract(test, "(?<=:).*Gambit") %>% str_squish()
      # Check the resulting substring for any commas
      if(str_detect(result, ",")){
        # If there's a comma, extract the substring between the comma and "Gambit", again keeping the latter
        result <- str_extract(result, "(?<=,).*Gambit") %>% str_squish()
        # Repeat if there's another comma left in there
        if(str_detect(result, ",")){result <- str_extract(result, "(?<=,).*Gambit") %>% str_squish()}
      } else {
        # If there isn't a comma, don't change the substring
        result <- result
      }
    }
    # If there's a colon and it appears AFTER "Gambit", extract the substring between the start of the string and "Gambit" 
    if(str_locate(test, ":")[1,1] > str_locate(test, "Gambit")[1,1]){
      result <- str_extract(test, "(?<=^).*Gambit") %>% str_squish()
    }
    # If there's no colon in the opening name, keep it the same
  } else{
    result <- test
  }
  gambits$gambit_name[i] <- result
}

# Now make sure all gambit names only have one "Gambit"
gambits <- gambits %>% 
  mutate(gambit_name = str_replace_all(gambit_name, "(?<=Gambit).*$", ""))

gambits <- gambits %>% 
  mutate(gambit_score = case_when(
    gambit_col == "white" & result == "1-0" ~ 1,
    gambit_col == "white" & result == "1/2-1/2" ~ 0.5,
    gambit_col == "white" & result == "0-1" ~ 0,
    gambit_col == "black" & result == "1-0" ~ 0,
    gambit_col == "black" & result == "1/2-1/2" ~ 0.5,
    gambit_col == "black" & result == "0-1" ~ 1,
    TRUE ~ NA_real_
  )) %>%
  select(gambit_name, gambit_score) %>%
  group_by(gambit_name) %>%
  summarise(games = n(),
            success = (sum(gambit_score) / games) * 100) %>%
  arrange(desc(games), desc(success))

gambits$rank <- data.table::frank(gambits, -games, -success, ties.method = "dense")

gambits <- gambits %>% 
  select(rank, gambit_name, games, success)

reactable(gambits,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
          compact = T,
           columns = list(
             rank = colDef(name = "Rank", align = "center", minWidth = 50),
    gambit_name = colDef(name = "Name", minWidth = 150),
    games = colDef(name = "Games", align = "center"),
    success = colDef(name = "White score (%)", format = colFormat(digits = 0), align = "center")
           )
    )
```


#### Gambiteers

The players who enjoyed the most success when playing gambits. 

*Shows all players who scored at least 50% playing gambits in the season (min. games: 2).*

```{r}
# Gambit lovers
gambiteers <- games %>%
  filter(gambit_col %in% c("white", "black")) %>% 
  mutate(player = case_when(
    gambit_col == "white" ~ white,
    gambit_col == "black" ~ black,
    TRUE ~ NA_character_
  )) %>% 
  mutate(gambit_score = case_when(
    gambit_col == "white" & result == "1-0" ~ 1,
    gambit_col == "white" & result == "1/2-1/2" ~ 0.5,
    gambit_col == "white" & result == "0-1" ~ 0,
    gambit_col == "black" & result == "1-0" ~ 0,
    gambit_col == "black" & result == "1/2-1/2" ~ 0.5,
    gambit_col == "black" & result == "0-1" ~ 1,
    TRUE ~ NA_real_
  )) %>% 
  select(id, player, opening.name, gambit_score) %>% 
  group_by(player) %>% 
  summarise(games = n(),
            success = sum(gambit_score) / games) %>%
  filter(games > 1, success >= 0.5)

if(nrow(gambiteers) > 0){
  gambiteer_award <- TRUE
  gambiteers <- gambiteers %>% arrange(desc(games), desc(success))
  gambiteers$rank <- data.table::frank(gambiteers, -games, -success, ties.method = "dense")
  gambiteers <- gambiteers %>% select(rank, player, games, success)
} else {
  gambiteer_award <- FALSE
  gambiteers <- tibble("rank" = "",
                       "player" = "",
                       "games" = "",
                       "success" = "")
}

reactable(gambiteers,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
          compact = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center", minWidth = 50),
    player = colDef(name = "Player", minWidth = 150),
    games = colDef(name = "Games", align = "center"),
    success = colDef(name = "% Score", format = colFormat(digits = 2), align = "center")
           )
    )
```


### Openings - sunburst

Click on the image below to see a sunburst plot of all openings played in the season.


<center>
[![Opening star placeholder](`r paste0("openings_", ifelse(league_load_label == "team4545", "4545", league_load_label), "_s", season, ".png")`){width=50%}](`r paste0("openings_", ifelse(league_load_label == "team4545", "4545", league_load_label), "_s", season, ".html")`){width=50%}
</center>


### Awards

<!-- All the code to determine the awards has to be run before the awards table -->

```{r relative_perfs}
perfs_w <- pairings %>% 
  filter(winner != "forfeit/unplayed") %>% 
  group_by(white) %>%
  summarise(sum_opp_rating = sum(rating_b),
            games = n(),
            points = ((sum(winner == "white") * 1) + (sum(winner == "draw") * 0.5)),
            wins = sum(winner == "white"),
            draws = sum(winner == "draw"),
            losses = sum(winner == "black"),
            initial_rating = rating_w[which.min(round)],
            initial_round = min(round)) %>% 
  rename("player" = white)

perfs_b <- pairings %>% 
  filter(winner != "forfeit/unplayed") %>% 
  group_by(black) %>%
  summarise(sum_opp_rating = sum(rating_w),
            games = n(),
            points = ((sum(winner == "black") * 1) + (sum(winner == "draw") * 0.5)),
            wins = sum(winner == "black"),
            draws = sum(winner == "draw"),
            losses = sum(winner == "white"),
            initial_rating = rating_b[which.min(round)],
            initial_round = min(round)) %>% 
  rename("player" = black)

perfs <- rbind(perfs_w, perfs_b)
rm(perfs_w, perfs_b)

# Compute performance ratings using FIDE method
perfs_fide <- perfs %>% 
  group_by(player) %>% 
  summarise(sum_opp_rating = sum(sum_opp_rating),
            games = sum(games),
            avg_opp_rating = sum_opp_rating / games,
            points = sum(points),
            tp_score = points / games,
            wins = sum(wins),
            draws = sum(draws),
            losses = sum(losses),
            initial_rating = initial_rating[which.min(initial_round)]) %>%
  mutate(adj = fide_tpr_lookup[match(round(tp_score, 2), fide_tpr_lookup$p),2]) %>% 
  mutate(perf_rating = avg_opp_rating + adj) %>% 
  mutate(perf_diff = perf_rating - initial_rating)

# Save as all perfs df
perfs <- perfs_fide
rm(perfs_fide)

# Produce relative perfs for report
relative_perfs <- perfs %>% 
  filter(games >= 5) %>% 
  filter(perf_diff >= 0) %>% 
  arrange(desc(perf_diff)) %>% 
  mutate(perf_rank = dense_rank(desc(perf_diff))) %>% 
  select(perf_rank, player, games, wins, draws, losses, initial_rating, perf_rating, perf_diff)

```

```{r}
season_error_rates <- error_rates %>% 
  group_by(player) %>% 
  summarise(season_acpl = sum(cpl, na.rm=T) / sum(moves, na.rm=T), 
            total_blunders = sum(blunders, na.rm = T),
            total_mistakes = sum(mistakes, na.rm = T),
            total_inaccuracies = sum(inaccuracies, na.rm = T),
            total_moves = sum(moves, na.rm = T)) %>% 
  filter(total_moves >= 100) %>% 
  arrange(season_acpl)
  
lowest_acpls <- season_error_rates %>% 
  head(100) %>%
  mutate(acpl_rank = dense_rank(season_acpl)) %>% 
  select(acpl_rank, player, total_moves, season_acpl)
```

```{r}
# Players with single-figure ACPLs

minacpl_players_w <- games %>% 
  arrange(players.white.analysis.acpl) %>% 
  select(white, players.white.analysis.acpl,
         id, result) %>% 
  mutate(colour = "w")
colnames(minacpl_players_w)[1:2] <- c("player", "acpl")

minacpl_players_b <- games %>% 
  arrange(players.black.analysis.acpl) %>% 
  select(black, players.black.analysis.acpl, id, result) %>% 
  mutate(colour = "b")
colnames(minacpl_players_b)[1:2] <- c("player", "acpl")

minacpl_players <- rbind(minacpl_players_w, minacpl_players_b) %>% 
  arrange(acpl) %>% 
  select(player, acpl, id)

rm(minacpl_players_w, minacpl_players_b)

# Show players with multiple single-figure ACPL games
minacpl_players <- minacpl_players %>%  
  filter(acpl < 10) %>% 
  group_by(player) %>% 
  tally() %>% 
  filter(n>1)

if(nrow(minacpl_players > 0)){
  minacpl_players <- minacpl_players %>% 
    arrange(desc(n)) %>% 
    slice_max(n)
}
  


```

```{r}
# Clock times spent per move (after move 10)
# Min. games: 3
avg_think_times <- rbind(tibble("player" = games$white, "duration" = games$clock_used_after_move10_w, "moves" = games$num_moves - 10),
                  tibble("player" = games$black, "duration" = games$clock_used_after_move10_b, "moves" = games$num_moves - 10)) %>% 
  filter(moves > 0) %>% 
  group_by(player) %>% 
  summarise(time_spent_after_move10 = sum(duration, na.rm = T),
            moves = sum(moves, na.rm = T),
            games = n(),
            avg_time_spent_after_move10 = time_spent_after_move10 / moves) %>% 
  arrange(desc(avg_time_spent_after_move10)) %>% 
  select(player, games, moves, avg_time_spent_after_move10, time_spent_after_move10) %>% 
  filter(games >= 3) %>% 
  mutate(prank = ntile(avg_time_spent_after_move10, 100)) %>%
  mutate(rank = dense_rank(desc(avg_time_spent_after_move10))) %>% 
  mutate(duration_print = sprintf('%2dm %2.1fs', lubridate::minute(seconds_to_period(avg_time_spent_after_move10)), lubridate::second(seconds_to_period(avg_time_spent_after_move10)))) %>% 
  select(rank, player, games, moves, duration_print, prank)

# Most think time across season
season_think <- rbind(tibble("player" = games$white, "duration" = games$duration_w, "moves" = games$num_moves),
                                  tibble("player" = games$black, "duration" = games$duration_b, "moves" = games$num_moves)) %>% 
  group_by(player) %>% 
  summarise(total_duration = lubridate::seconds_to_period(sum(duration, na.rm = T)),
            total_moves = sum(moves, na.rm = T),
            games = n()) %>% 
  arrange(desc(total_duration)) %>% 
  mutate(rank = dense_rank(desc(total_duration))) %>% 
  mutate(duration_print = sprintf('%2dh %2dm %2ds', lubridate::hour(total_duration), lubridate::minute(total_duration), lubridate::second(total_duration))) %>% 
  select(rank, player, games, duration_print) %>% 
  head(50)

# Players who've played in the longest games
most_playing_time <- rbind(tibble("player" = games$white, "duration" = games$duration),
                                   tibble("player" = games$black, "duration" = games$duration)) %>% 
  group_by(player) %>% 
  summarise(total_duration = lubridate::seconds_to_period(sum(duration, na.rm = T)),
            games = n()) %>% 
  arrange(desc(total_duration)) %>% 
  mutate(rank = dense_rank(desc(total_duration))) %>% 
  mutate(duration_print = sprintf('%2gh %2gm %2.0fs', lubridate::hour(total_duration), lubridate::minute(total_duration), lubridate::second(total_duration))) %>% 
  select(rank, player, games, duration_print) %>% 
  head(50)
```


```{r}
# Identify Giri Award winner - most draws
drawers <- pairings %>% 
  filter(winner == "draw") %>% 
  select(white, black)

drawers <- c(drawers$white, drawers$black)

drawers <- tibble("player" = drawers) %>% 
  group_by(player) %>% 
  tally() %>% 
  arrange(desc(n)) %>% 
  slice_max(n)
```


```{r}
# Comebacks

comebacks <- games %>% 
  mutate(end_eval = case_when(
    winner == "white" ~ 1,
    winner == "black" ~ -1,
    status == "draw" ~ 0,
    status == "stalemate" ~ 0,
    TRUE ~ NA_real_
  )) %>% 
  select(id, white, black, end_eval, evals)

comebacks$max_eval <- rep(NA, nrow(comebacks))
comebacks$min_eval <- rep(NA, nrow(comebacks))

for(i in seq(1:nrow(comebacks))){
  comebacks$max_eval[i] <- max(comebacks$evals[i][[1]]$eval_scaled)
  comebacks$min_eval[i] <- min(comebacks$evals[i][[1]]$eval_scaled)
}

comebacks <- comebacks %>% 
  mutate(comeback_w = if_else(end_eval %in% c(0,1), abs(end_eval - min_eval), 0),
         comeback_b = if_else(end_eval %in% c(0,-1), abs(end_eval - max_eval), 0))

cw <- comebacks %>% select("player" = white, "comeback" = comeback_w)
cb <- comebacks %>% select("player" = black, "comeback" = comeback_b)

comebacks_2 <- bind_rows(cw, cb)

comebacks_2 <- comebacks_2 %>% 
  group_by(player) %>% 
  summarise(games = n(),
            total_cb = sum(comeback),
            avg_cb = total_cb / games) %>% 
  arrange(desc(total_cb)) %>%
  filter(games >= 3) %>% 
  filter(avg_cb > 0) %>% 
  mutate(rank = dense_rank(desc(total_cb))) %>% 
  select(rank, player, avg_cb, total_cb)
```


```{r}
# Biggest upsets
upsets <- pairings %>%
  filter((rating_w < rating_b & winner == "white") |
           (rating_b < rating_w & winner == "black")) %>% 
  mutate(rating_gap = abs(rating_w - rating_b)) %>% 
  select(white, black, winner, rating_gap) %>% 
  mutate(player = if_else(winner == "white", white, black)) %>% 
  arrange(desc(rating_gap)) %>%
  filter(rating_gap >= 50) %>% 
  mutate(rank = dense_rank(desc(rating_gap))) %>% 
  select(rank, player, rating_gap)

# Repeat upset specialists
upset_specialists <- upsets %>% 
  group_by(player) %>% 
  summarise(upsets = n(),
            mean_rating_gap = mean(rating_gap),
            max_rating_gap = max(rating_gap),
            upset_pts = sum(rating_gap)) %>%
  filter(upsets > 1) %>% 
  arrange(desc(upset_pts)) %>% 
  mutate(rank = dense_rank(desc(upset_pts))) %>% 
  select(rank, player, upset_pts, upsets, mean_rating_gap, max_rating_gap)

```


```{r}
# Other Grischuk Award: least time left after move 10, but winning
dawdlers <- data.table::rbindlist(games$evals) %>% 
  filter(ply %in% c(18, 19)) %>%
  arrange(time_left)

dawdlers <- left_join(dawdlers, games, by = c("game_id" = "id")) %>% 
  select("id" = game_id, ply, eval, time_left, white, black, result) %>% 
  mutate(player = if_else(ply %% 2 == 1, black, white),
         outcome = case_when(
           player == white & result == "1-0" ~ "Win",
           player == white & result == "0-1" ~ "Loss",
           player == black & result == "1-0" ~ "Loss",
           player == black & result == "0-1" ~ "Win",
           result == "1/2-1/2" ~ "Draw",
           TRUE ~ NA_character_
         )) %>%
  mutate(url = paste0("https://lichess.org/", id, "#", ply+1)) %>% 
  select(player, url, time_left, outcome) %>% 
  arrange(time_left) %>% 
  mutate(time_left_2 = lubridate::seconds_to_period(time_left)) %>% 
  mutate(time_print = sprintf('%2dm %2ds', lubridate::minute(time_left_2), lubridate::second(time_left_2))) %>% 
  filter(outcome == "Win") %>% 
  head(10) %>% 
  mutate("rank" = dense_rank(time_left)) %>% 
  select(rank, player, time_print, outcome, url)
  

if(dawdlers$time_print[1] == "NAm NAs"){
  dawdler_award <- FALSE
} else{
  dawdler_award <- TRUE
}

```

```{r}

# Get dataset of all moves in games data
all_moves <- data.table::rbindlist(games$evals) %>% 
  mutate(colour = case_when(
    ply %% 2 == 0 ~ "white",
    ply %% 2 == 1 ~ "black",
    TRUE ~ NA_character_
  )) 

# Add id, White, Black, winner (white, black, NA)
games_basics <- games %>% select(id, white, black, winner, result)

all_moves <- left_join(all_moves, games_basics, by = c("game_id" = "id")) %>% 
  mutate(player = ifelse(colour == "white", white, black)) %>% 
  group_by(player) %>% 
  add_tally() %>% 
  rename("player_total_moves" = n) %>% 
  mutate(player_outcome = case_when(
    colour == "white" & winner == "white" ~ "win",
    colour == "black" & winner == "black" ~ "win",
    TRUE ~ NA_character_
  )) %>% 
  # Get preceding position eval from the mover's perspective 
  mutate(player_eval_prev = case_when(
    colour == "white" ~ capped_eval_prev,
    colour == "black" ~ capped_eval_prev * -1,
    TRUE ~ NA_real_
  ))


```


```{r}
# Players with the most near-instant moves (< 0.5s)
# Played more than 5 instant moves

instamovers <- all_moves %>% 
  filter(time_spent < 1)

if(nrow(instamovers) > 0){
  instamovers <- instamovers %>% 
    select(game_id, ply, time_spent, white, black, result) %>% 
    mutate(player = if_else(ply %% 2 == 1, black, white)) %>% 
    group_by(player) %>% 
    summarise(instamoves = n()) %>% 
    arrange(desc(instamoves)) %>%
    filter(instamoves > 5) %>% 
    mutate(rank = dense_rank(desc(instamoves))) %>% 
    select(rank, player, instamoves)
} else {
  instamovers <- tibble("rank" = 1, "player" = "n/a", "instamoves" = "n/a")
}

```


```{r}
# Longest movetimes (top 100)
movetimes <- data.table::rbindlist(games$evals) %>% 
  mutate(colour = case_when(
    ply %% 2 == 0 ~ "white",
    ply %% 2 == 1 ~ "black",
    TRUE ~ NA_character_
  )) %>% 
  arrange(desc(time_spent))

games_basics <- games %>% select(id, white, black)

movetimes <- left_join(movetimes, games_basics, by = c("game_id" = "id")) %>% 
  mutate(player = ifelse(colour == "white", white, black),
         url = paste0("https://lichess.org/", game_id, "#", ply+1)) %>% 
  mutate(rank = dense_rank(desc(time_spent))) %>% 
  select(rank, player, time_spent, colour, ply, url) %>%
  mutate(time_spent = lubridate::seconds_to_period(time_spent),
         move = ifelse(ply %% 2 == 0, ply/2+1, (ply/2)+0.5)) %>% 
  mutate(time_spent = sprintf('%2dm %2ds', lubridate::minute(time_spent), lubridate::second(time_spent))) %>% 
  mutate(colour = str_to_title(colour)) %>% 
  select(rank, player, time_spent, colour, move, url) %>% 
  head(100)
```



```{r}
# Saved by the bell
savedbythebell <- all_moves %>% 
  filter(time_left < 6,
         player_outcome == "win") %>%
  select(player, game_id, white, black, time_left, "eval" = player_eval_prev) %>% 
  group_by(player, game_id) %>% 
  summarise(panic_moves = n(), min_time_left = min(time_left), worst_eval = min(eval)) %>% 
  filter(worst_eval <= 300) %>% # excludes players who played last-second moves in winning positions
  arrange(desc(panic_moves), min_time_left, worst_eval) %>% 
  mutate(url = paste0("https://lichess.org/", game_id)) %>% 
  select(player, panic_moves, min_time_left, url)

```


```{r}
# Highest % of moves in time trouble (<60s)

timetrouble <- all_moves %>% 
  filter(time_left < 60) %>% 
  group_by(player) %>% 
  summarise(tt_moves = n(),
            moves = max(player_total_moves),
            tt_pc = tt_moves/moves) %>% 
  arrange(desc(tt_pc)) %>%
  filter(moves > 100) %>% # min threshold 100 moves
  mutate(rank = dense_rank(desc(tt_pc))) %>% 
  select(rank, player, moves, tt_moves, tt_pc)
```

```{r radjabov_award}
# Radjabov Award: find draws agreed in winning positions

# # Extract all moves from games data
# all_moves <- data.table::rbindlist(games$evals) %>% 
#   mutate(colour = case_when(
#     ply %% 2 == 0 ~ "white",
#     ply %% 2 == 1 ~ "black",
#     TRUE ~ NA_character_
#   )) 
# 
# # Add game ID, player names, and the result
# games_basics <- games %>% select(id, white, black, result)
# 
# all_moves <- left_join(all_moves, games_basics, by = c("game_id" = "id")) %>% 
#   mutate(player = ifelse(colour == "white", white, black))

radjabov <- all_moves %>% 
  group_by(game_id) %>% 
  slice(which.max(ply)) %>%
  summarise(result = result,
            white = white,
            black = black, 
            final_ply = ply,
            final_eval = eval_scaled,
            abs_final_eval = abs(final_eval)) %>% 
  filter(result == "1/2-1/2") %>% 
  arrange(desc(abs_final_eval)) %>% 
  mutate(player = ifelse(final_eval > 0, white, black)) %>% 
  head(3)

# Change to fastest draw
games %>% 
  filter(result == "1/2-1/2") %>% 
  arrange(num_moves) %>% 
  select(id, white, black, num_moves) %>% 
  head(5)


```


```{r david_award}
# David Award (suggested by Tranzoo)
# For the player who faced the opponents with the highest collective score across
# the season (excluding games against the player)

david <- games %>% 
  select(white, black, result, score_w, score_b) %>%
  left_join(perfs, by = c("white" = "player")) %>% 
  select(white, black, score_w, score_b, "games_w" = games, "points_w" = points) %>% 
  mutate(games_aw = games_w - 1, points_aw = points_w - score_w) %>% 
  left_join(perfs, by = c("black" = "player")) %>% 
  select(white, black, score_w, score_b, games_aw, points_aw, "games_b" = games, "points_b" = points) %>%
  mutate(games_ab = games_b - 1, points_ab = points_b - score_b) %>% 
  select(white, black, games_aw, games_ab, points_aw, points_ab)

david <- rbind(tibble("player" = david$white,
                      "opp_adjgames" = david$games_ab,
                      "opp_adjpoints" = david$points_ab),
               tibble("player" = david$black,
                      "opp_adjgames" = david$games_aw,
                      "opp_adjpoints" = david$points_aw)) %>% 
  group_by(player) %>% 
  summarise(opp_games = sum(opp_adjgames),
            opp_points = sum(opp_adjpoints),
            opp_perc = opp_points / opp_games) %>% 
  filter(opp_games >= 20) %>% 
  filter(opp_perc >= 0.5) %>% 
  mutate(opp_perc = opp_perc * 100) %>% 
  arrange(desc(opp_perc)) %>% 
  mutate(rank = seq(1:nrow(.)))
  
  
```

```{r team_stats, eval = ifelse(league == "team4545", TRUE, FALSE)}
# Compute team stats

team_data <- games %>% 
  select(season, round, board, id, white, black, result, num_moves, score_w, 
         score_b, team_w, team_b, gp_w, gp_b,
         "acpl_w" = players.white.analysis.acpl,
         "acpl_b" = players.white.analysis.acpl,
         "blunders_w" = players.white.analysis.blunder,
         "blunders_b" = players.black.analysis.blunder,
         duration, duration_w, duration_b, eval_after_15, evals,
         match
         ) %>% 
  # Games played with the wrong colours can't be assigned teams (currently)
  # Excluding these prevents the appearance of any NA rows in the final team data
  filter(!(is.na(team_w))) %>% 
  filter(!(is.na(team_b)))

team_data_w <- tibble("team" = team_data$team_w, "player" = team_data$white,
                      "score" = team_data$score_w, "board" = team_data$board,
                      "acpl" = team_data$acpl_w, "blunders" = team_data$blunders_w,
                      "moves" = team_data$num_moves, "game_duration" = team_data$duration,
                      "player_duration" = team_data$duration_w,
                      "cpl" = team_data$acpl_w * team_data$num_moves)
team_data_b <- tibble("team" = team_data$team_b, "player" = team_data$black,
                      "score" = team_data$score_b, "board" = team_data$board,
                      "acpl" = team_data$acpl_b, "blunders" = team_data$blunders_b,
                      "moves" = team_data$num_moves, "game_duration" = team_data$duration,
                      "player_duration" = team_data$duration_b,
                      "cpl" = team_data$acpl_w * team_data$num_moves)

team_data <- rbind(team_data_w, team_data_b) %>% 
  group_by(team) %>% 
  summarise(players = n_distinct(player),
            games = n(),
            pts_nonforf = sum(score, na.rm = T),
            wins = sum(score == 1, na.rm = T),
            draws = sum(score == 0.5, na.rm = T),
            losses = sum(score == 0, na.rm = T),
            acpl = sum(cpl, na.rm = T) / sum(moves, na.rm = T),
            avg_moves = mean(moves, na.rm = T),
            blunder_pc = sum(blunders, na.rm = T) / sum(moves, na.rm = T)
  )

rm(team_data_w, team_data_b)

# Add teams' final game points total (incl. forfeits/sched. draws etc) to team data
team_points <- positions %>%
  filter(round == 8) %>% 
  select(rank, team, "points" = gp)

team_data <- left_join(team_data, team_points, by = c("team"))

team_data <- team_data %>% 
  mutate(blunder_pc = blunder_pc * 100) %>%
  arrange(rank) %>% 
  select(rank, team, games, points, pts_nonforf, wins, draws, losses, players,
         avg_moves, acpl, blunder_pc)

# Get lowest team ACPL for awards
team_accuracy_award <- team_data %>% 
  arrange(acpl) %>% 
  filter(!(is.na(team))) %>%
  slice_min(acpl) %>% 
  select(team, acpl)


```


```{r egalitarianism, eval = ifelse(league == "team4545", TRUE, FALSE)}
# ---- MOST EGALITARIAN TEAMS ----
# Silkthewander's suggestion
# Award for the team with the lowest standard deviation of players' relative performance ratings over the season, 
# where one's rel. perf rating = their actual perf. rating minus their initial rating

# Gather data on all players and their teams
players_teams <- rbind(tibble("player" = games$white, "team" = games$team_w, "round" = games$round),
                       tibble("player" = games$black, "team" = games$team_b, "round" = games$round)) %>% 
  group_by(player, team) %>% 
  summarise(games = n()) 

# Construct variant dataset for obtaining relative perf ratings 
players_teams_2 <- players_teams %>% 
  mutate(player = str_to_lower(player))

# Compute team egalitarianism score
egalitarian <- players_teams %>% 
  left_join(perfs, by = c("player")) %>% 
  group_by(team) %>% 
  summarise(egalite = sd(perf_diff, na.rm = T)) %>% 
  arrange(egalite) %>% 
  filter(!(is.na(team)))




```


```{r alts, eval = ifelse(league == "team4545", TRUE, FALSE)}
# Highlight alternates
# Criteria: played for more than 1 team, or played only 1 game
alts <- players_teams %>% 
  group_by(player) %>% 
  summarise(games = sum(games, na.rm = T),
            teams = n_distinct(team)) %>% 
  filter(teams > 1 | games == 1) %>% 
  arrange(desc(teams)) %>% 
  mutate(rank = min_rank(-teams))

# Identify player who played for the most teams
alt_award <- alts %>% filter(rank == 1) 

# Identify player(s) who played for the second-highest number of teams
alt_runnerup <- alts %>% 
  filter(rank > 1) %>% 
  slice_max(teams)



```

<!-- Player awards code: 1st table for 4545, 2nd table for LW -->

```{r player_awards_4545, eval = ifelse(league == "team4545", TRUE, FALSE)}

single_fig_acpl_players <- minacpl_players %>% select(player) %>% dplyr::pull()
giri_winners <- drawers %>% select(player) %>% dplyr::pull()
giri_value <- drawers %>% select(n) %>% distinct() %>% dplyr::pull()

if(league == "team4545"){
alt_winners <- alt_award %>% select(player) %>% dplyr::pull() %>% str_c(collapse = ", ")
alt_value <- alt_award %>% select(teams) %>% dplyr::pull() %>% unique()
alt_runnerup_names <- alt_runnerup %>% select(player) %>% dplyr::pull()
alt_runnerup_value <- alt_runnerup %>% select(teams) %>% distinct() %>% dplyr::pull() 
}

awards <- tibble("Image" = c(rep("x", 18)),
                 "Award" = c("Gambit Guru",
                             "MVP Award",
                             "Archbishop of Accuracy",
                             "Primates of Precision",
                             "Tetrarch of Time",
                             "Giri Award",
                             "Houdini Award",
                             "Tarjan Award",
                             "Slingshot Specialist",
                             "Grischuk's Cousin",
                             "Bullet Boss",
                             "Musing or Snoozing",
                             "Intimate with Increment",
                             "Saved by the Bell",
                             "Radjabov Award",
                             "David Award",
                             ifelse(league == "team4545", "Awesome Alt", ""),
                             ifelse(league == "team4545", "Team Accuracy", "")
                             ),
                 
                 "Definition" = c("Best score playing gambits",
                                  "Best performance rating relative to initial rating",
                                  "Lowest ACPL",
                                  "Most games < 10 ACPL",
                                  "Spent the most clock time across the season",
                                  "Most draws",
                                  "Biggest comebacks",
                                  "Achieved the biggest upset",
                                  "Achieved the most upsets across the season",
                                  "Least time remaining after 10th move",
                                  "Most moves made in under 0.5s",
                                  "Longest time spent on a move",
                                  "Highest percentage of moves played with < 1 min left",
                                  "Most moves made with < 5s left before winning",
                                  "Securing a draw from the jaws of victory",
                                  "Faced the strongest opposition",
                                  ifelse(league == "team4545", "Played for the most teams during the season", ""),
                                  ifelse(league == "team4545", "Lowest team ACPL", "")),
                 
                 "Winner" = c(gambiteers$player[1],
                              relative_perfs$player[1],
                              lowest_acpls$player[1],
                              str_c(single_fig_acpl_players, collapse = ", "),
                              ifelse(movetimes_exist, season_think$player[1], ""),
                              str_c(giri_winners, collapse = ", "),
                              comebacks_2$player[1],
                              upsets$player[1],
                              upset_specialists$player[1],
                              ifelse(movetimes_exist, dawdlers$player[1], ""),
                              ifelse(movetimes_exist, instamovers$player[1], ""),
                              ifelse(movetimes_exist, movetimes$player[1], ""),
                              ifelse(movetimes_exist, timetrouble$player[1], ""),
                              ifelse(movetimes_exist, savedbythebell$player[1], ""),
                              radjabov$player[1],
                              david$player[1],
                              ifelse(league == "team4545", str_c(alt_winners, collapse = ", "), ""),
                              ifelse(league == "team4545", team_accuracy_award$team[1], "")
                              ),
                 
                 "Details" = c(ifelse(gambiteer_award, paste0(round(gambiteers$success[1] * 100), "% from ", gambiteers$games[1], " games"), "Can't be awarded"),
                              paste0("Perf. rating: ", round(relative_perfs$perf_rating[1], 0), " (initial rating: ",
                                     relative_perfs$initial_rating[1], ")"),
                              paste0(round(lowest_acpls$season_acpl[1], 1), " ACPL over ", lowest_acpls$total_moves[1], " moves"),
                              paste0(minacpl_players$n[1], " games"),
                              ifelse(movetimes_exist, paste0(season_think$duration_print[1]), "Can't be awarded"),
                              paste0(giri_value, " draws"),
                              "",
                              paste0("Won despite being outrated by ", upsets$rating_gap[1], " points"),
                              paste0(upset_specialists$upsets[1], " upsets (", "biggest: ", upset_specialists$max_rating_gap[1], " pts)"),
                              ifelse(movetimes_exist, paste0("Had ", dawdlers$time_print[1], " left after 10 moves"), "Can't be awarded"),
                              ifelse(movetimes_exist, paste0(instamovers$instamoves[1], " moves"), "Can't be awarded"),
                              ifelse(movetimes_exist, paste0("Spent ", movetimes$time_spent[1]), "Can't be awarded"),
                              ifelse(movetimes_exist, paste0(round(timetrouble$tt_pc[1]*100, 1), "% (", timetrouble$tt_moves[1], "/", timetrouble$moves[1], ")"), "Can't be awarded"),
                              ifelse(movetimes_exist, paste0(savedbythebell$panic_moves[1], " move(s) in ", savedbythebell$url[1]), "Can't be awarded"),
                              "",
                             paste0("Opponents' record: ", david$opp_points[1], "/", david$opp_games[1]),
                             ifelse(league == "team4545", paste0("Played for ", alt_value, " different teams"), ""),
                             ifelse(league == "team4545", paste0("Team ACPL: ", round(team_accuracy_award$acpl[1], 1)), "")
                             ),
                 
                 "Mentions" = c(ifelse(gambiteer_award, str_c(gambiteers$player[2:3], collapse = ", "), ""),
                              str_c(relative_perfs$player[2:3], collapse = ", "),
                              str_c(lowest_acpls$player[2:3], collapse = ", "),
                              "",
                              ifelse(movetimes_exist, str_c(season_think$player[2:3], collapse = ", "), ""),
                              "",
                              str_c(comebacks_2$player[2:3], collapse = ", "),
                              str_c(upsets$player[2:3], collapse = ", "),
                              str_c(upset_specialists$player[2:3], collapse = ", "),
                              ifelse(movetimes_exist, str_c(dawdlers$player[2:3], collapse = ", "), ""),
                              ifelse(movetimes_exist, str_c(instamovers$player[2:3], collapse = ", "), ""),
                              ifelse(movetimes_exist, str_c(movetimes$player[2:3], collapse = ", "), ""),
                              ifelse(movetimes_exist, str_c(timetrouble$player[2:3], collapse = ", "), ""),
                              ifelse(movetimes_exist, str_c(savedbythebell$player[2:3], collapse = ", "), ""),
                              str_c(radjabov$player[2:3], collapse = ", "),
                              str_c(david$player[2:3], collapse = ", "),
                              ifelse(league == "team4545", paste0(str_c(alt_runnerup_names, collapse = ", "), " (", alt_runnerup_value, ")"), ""),
                              "")
                 
                 )

# Re-arrange columns
awards <- awards %>% 
  select(Image, Award, Definition, Winner, Details, Mentions) %>% 
  arrange(Award) %>% 
  filter(!(is.na(Award)))

# Show player awards table
reactable(awards,
          pagination = F,
          highlight = F,
          striped = T,
          searchable = F,
          fullWidth = T,
          resizable = T,
          outlined = T,
          compact = F,
          columns = list(
            Image = colDef(name = "Award", 
                           cell = function(value, index) {
                             award_name <- awards$Award[index]
                             image <- img(src = sprintf("images/%s.png", award_name), height = "60px", alt = award_name)
              tagList(
                div(style = list(display = "inline-block", width = "60px"), image)
                )
              }),
            Award = colDef(name = "Description", minWidth = 150,
                           # Show award definition/criteria under each name
                           cell = function(value, index) {
                             definition <- awards$Definition[index]
                             definition <- if (!is.na(definition)) definition else "n/a"
                             tagList(
                               div(style = list(fontWeight = 600), value),
                               div(style = list(fontSize = 12), definition)
                               )
                             }),
            Winner = colDef(name = "Winner", minWidth = 150,
                            style = list(color = "#245164")),
            Definition = colDef(show = F),
            Details = colDef(name = "Details", minWidth = 200),
            Mentions = colDef(name = "Honourable mentions", minWidth = 180)
          )
)
```

```{r player_awards_lw, eval = ifelse(league == "team4545", FALSE, TRUE)}

single_fig_acpl_players <- minacpl_players %>% select(player) %>% dplyr::pull()
giri_winners <- drawers %>% select(player) %>% dplyr::pull()
giri_value <- drawers %>% select(n) %>% distinct() %>% dplyr::pull()

awards <- tibble("Image" = c(rep("x", 16)),
                 "Award" = c("Gambit Guru",
                             "MVP Award",
                             "Archbishop of Accuracy",
                             "Primates of Precision",
                             "Tetrarch of Time",
                             "Giri Award",
                             "Houdini Award",
                             "Tarjan Award",
                             "Slingshot Specialist",
                             "Grischuk's Cousin",
                             "Bullet Boss",
                             "Musing or Snoozing",
                             "Intimate with Increment",
                             "Saved by the Bell",
                             "Radjabov Award",
                             "David Award"
                             ),
                 
                 "Definition" = c("Best score playing gambits",
                                  "Best performance rating relative to initial rating",
                                  "Lowest ACPL",
                                  "Most games < 10 ACPL",
                                  "Spent the most clock time across the season",
                                  "Most draws",
                                  "Biggest comebacks",
                                  "Achieved the biggest upset",
                                  "Achieved the most upsets across the season",
                                  "Least time remaining after 10th move",
                                  "Most moves made in under 0.5s",
                                  "Longest time spent on a move",
                                  "Highest percentage of moves played with < 1 min left",
                                  "Most moves made with < 5s left before winning",
                                  "Securing a draw from the jaws of victory",
                                  "Faced the strongest opposition"),
                 
                 "Winner" = c(gambiteers$player[1],
                              relative_perfs$player[1],
                              lowest_acpls$player[1],
                              str_c(single_fig_acpl_players, collapse = ", "),
                              ifelse(movetimes_exist, season_think$player[1], ""),
                              str_c(giri_winners, collapse = ", "),
                              comebacks_2$player[1],
                              upsets$player[1],
                              upset_specialists$player[1],
                              ifelse(movetimes_exist, dawdlers$player[1], ""),
                              ifelse(movetimes_exist, instamovers$player[1], ""),
                              ifelse(movetimes_exist, movetimes$player[1], ""),
                              ifelse(movetimes_exist, timetrouble$player[1], ""),
                              ifelse(movetimes_exist, savedbythebell$player[1], ""),
                              radjabov$player[1],
                              david$player[1]),
                 
                 "Details" = c(ifelse(gambiteer_award, paste0(round(gambiteers$success[1] * 100), "% from ", gambiteers$games[1], " games"), "Can't be awarded"),
                              paste0("Perf. rating: ", round(relative_perfs$perf_rating[1], 0), " (initial rating: ",
                                     relative_perfs$initial_rating[1], ")"),
                              paste0(round(lowest_acpls$season_acpl[1], 1), " ACPL over ", lowest_acpls$total_moves[1], " moves"),
                              paste0(minacpl_players$n[1], " games"),
                              ifelse(movetimes_exist, paste0(season_think$duration_print[1]), "Can't be awarded"),
                              paste0(giri_value, " draws"),
                              "",
                              paste0("Won despite being outrated by ", upsets$rating_gap[1], " points"),
                              paste0(upset_specialists$upsets[1], " upsets (", "biggest: ", upset_specialists$max_rating_gap[1], " pts)"),
                              ifelse(movetimes_exist, paste0("Had ", dawdlers$time_print[1], " left after 10 moves"), "Can't be awarded"),
                              ifelse(movetimes_exist, paste0(instamovers$instamoves[1], " moves"), "Can't be awarded"),
                              ifelse(movetimes_exist, paste0("Spent ", movetimes$time_spent[1]), "Can't be awarded"),
                              ifelse(movetimes_exist, paste0(round(timetrouble$tt_pc[1]*100, 1), "% (", timetrouble$tt_moves[1], "/", timetrouble$moves[1], ")"), "Can't be awarded"),
                              ifelse(movetimes_exist, paste0(savedbythebell$panic_moves[1], " move(s) in ", savedbythebell$url[1]), "Can't be awarded"),
                              "",
                             paste0("Opponents' record: ", david$opp_points[1], "/", david$opp_games[1])
                             ),
                 
                 "Mentions" = c(ifelse(gambiteer_award, str_c(gambiteers$player[2:3], collapse = ", "), ""),
                              str_c(relative_perfs$player[2:3], collapse = ", "),
                              str_c(lowest_acpls$player[2:3], collapse = ", "),
                              "",
                              ifelse(movetimes_exist, str_c(season_think$player[2:3], collapse = ", "), ""),
                              "",
                              str_c(comebacks_2$player[2:3], collapse = ", "),
                              str_c(upsets$player[2:3], collapse = ", "),
                              str_c(upset_specialists$player[2:3], collapse = ", "),
                              ifelse(movetimes_exist, str_c(dawdlers$player[2:3], collapse = ", "), ""),
                              ifelse(movetimes_exist, str_c(instamovers$player[2:3], collapse = ", "), ""),
                              ifelse(movetimes_exist, str_c(movetimes$player[2:3], collapse = ", "), ""),
                              ifelse(movetimes_exist, str_c(timetrouble$player[2:3], collapse = ", "), ""),
                              ifelse(movetimes_exist, str_c(savedbythebell$player[2:3], collapse = ", "), ""),
                              str_c(radjabov$player[2:3], collapse = ", "),
                              str_c(david$player[2:3], collapse = ", ")
                 ))

# Re-arrange columns
awards <- awards %>% 
  select(Image, Award, Definition, Winner, Details, Mentions) %>% 
  arrange(Award) %>% 
  filter(!(is.na(Award)))

# Show player awards table
reactable(awards,
          pagination = F,
          highlight = F,
          striped = T,
          searchable = F,
          fullWidth = T,
          resizable = T,
          outlined = T,
          compact = F,
          columns = list(
            Image = colDef(name = "Award", 
                           cell = function(value, index) {
                             award_name <- awards$Award[index]
                             image <- img(src = sprintf("images/%s.png", award_name), height = "60px", alt = award_name)
              tagList(
                div(style = list(display = "inline-block", width = "60px"), image)
                )
              }),
            Award = colDef(name = "Description", minWidth = 150,
                           # Show award definition/criteria under each name
                           cell = function(value, index) {
                             definition <- awards$Definition[index]
                             definition <- if (!is.na(definition)) definition else "n/a"
                             tagList(
                               div(style = list(fontWeight = 600), value),
                               div(style = list(fontSize = 12), definition)
                               )
                             }),
            Winner = colDef(name = "Winner", minWidth = 150,
                            style = list(color = "#225622")),
            Definition = colDef(show = F),
            Details = colDef(name = "Details", minWidth = 200),
            Mentions = colDef(name = "Honourable mentions", minWidth = 180)
          )
)

```

### Detailed stats

All the following tables are sortable and searchable.

```{r results='asis', echo=FALSE}
# Hide team stats section from LW reports
if (lw_hide) {cat("<!---")}
```


#### Team statistics

```{r team_stats_appendix, eval = ifelse(league == "team4545", TRUE, FALSE)}
# Show team stats table in appendix

# data <- as_tibble(mtcars[1:6, ], rownames = "car") %>%
#   select(car:hp)

# Custom tooltips
with_tooltip <- function(value, tooltip, ...) {
  div(style = "text-decoration: underline; text-decoration-style: dotted; cursor: help",
      tippy(value, tooltip, ...))
}

# Show team data
reactable(
  team_data, pagination = T, searchable = T, fullWidth = T, resizable = T,
  compact = T,
  columns = list(
    team = colDef(minWidth = 200,
                  name = "Team"),
    players = colDef(minWidth = 50,
                     align = "center",
                     header = with_tooltip("Size", "# players who played for the team through the season")),
    games = colDef(minWidth = 50,
                   align = "center",
                   header = with_tooltip("G", "Team games, excl. forfeits")),
    pts_nonforf = colDef(minWidth = 50,
                         align = "center",
                   header = with_tooltip("P", "Team points, excl. forfeits")),
    wins = colDef(minWidth = 50,
                  align = "center",
                   header = with_tooltip("W", "Wins, excl. forfeits")),
    draws = colDef(minWidth = 50,
                   align = "center",
                   header = with_tooltip("D", "Draws, excl. forfeits")),
    losses = colDef(minWidth = 50,
                   header = with_tooltip("L", "Losses, excl. forfeits")),
    acpl = colDef(minWidth = 50, name = "ACPL",
                  align = "center",
                  format = colFormat(digits = 1)),
    blunder_pc = colDef(minWidth = 50,
                        align = "center",
                        format = colFormat(digits = 1),
                        header = with_tooltip("B", "Team blunder rate (%)")),
    rank = colDef(minWidth = 50,
                  align = "center",
                  header = with_tooltip("Rank", "Final rank (ignoring tiebreaks)")),
    points = colDef(minWidth = 50,
                    align = "center",
                    header = with_tooltip("GP", "Total game points")),
    avg_moves = colDef(minWidth = 50,
                       align = "center",
                       format = colFormat(digits = 1),
                       header = with_tooltip("M", "Average moves per game"))
    )
  )
```

```{r results='asis', echo=FALSE}
# End hiding stuff from LW reports
if(lw_hide){cat("-->")}
```

#### Best performances / highest accuracy {.tabset .tabset-fade .tabset-pills} 


##### Best relative perfs

Shows players' *relative* performance ratings: season performance rating minus initial rating.^[The season performance ratings presented in this report may differ slightly from the figures given by the Lichess4545 website. Both figures are based on FIDE's preferred calculation method and exclude unplayed games (such as forfeit wins/losses and scheduling draws.]

*Includes all players with a positive relative performance rating over at least five games.*




```{r}
# Table for report
reactable(relative_perfs,
          pagination = TRUE, 
          fullWidth = TRUE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             perf_rank = colDef(name = "#", align = "center", minWidth = 40),
    player = colDef(name = "Player", minWidth = 200),
    games = colDef(name = "Games", align = "center", minWidth = 60),
    wins = colDef(name = "W", align = "center", minWidth = 40),
    draws = colDef(name = "D", align = "center", minWidth = 40),
    losses = colDef(name = "L", align = "center", minWidth = 40),
    initial_rating = colDef(name = "Initial", align = "center", minWidth = 70),
    perf_rating = colDef(name = "Perf", format = colFormat(digits = 0), align = "center", minWidth = 70),
    perf_diff = colDef(name = "Diff.", format = colFormat(digits = 0), align = "center", minWidth = 70)),
    compact = TRUE)
```


##### Lowest ACPL

*Includes the 100 players with the lowest ACPL (min. 100 moves played).*

```{r show_lowest_acpls}
reactable(lowest_acpls,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             acpl_rank = colDef(name = "Rank", align = "center"),
    player = colDef(name = "Player", minWidth = 200),
    total_moves = colDef(name = "Moves", align = "center"),
    season_acpl = colDef(name = "ACPL", format = colFormat(digits = 2), align = "center")),
    compact = TRUE)
```



#### Time spent / strongest opponents {.tabset .tabset-fade .tabset-pills} 

##### Time spent

*Includes the 50 players who spent the most clock time over the season.*

```{r, comment = ""}

if(movetimes_exist){
reactable(season_think,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center"),
    player = colDef(name = "Player", minWidth = 200),
    games = colDef(name = "Games", align = "center"),
    duration_print = colDef(name = "Total time spent")),
    compact = TRUE)
} else {
  print(no_movetimes_print)
}

```

##### Time spent per move (after move 10)

*Includes everyone who played at least three games.*

```{r thinkers, comment=""}
if(movetimes_exist){
reactable(avg_think_times,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center"),
    player = colDef(name = "Player", minWidth = 200),
    games = colDef(name = "Games", align = "center"),
    moves = colDef(name = "Moves", align = "center"),
    duration_print = colDef(name = "Time spent per move", minWidth = 150),
    prank = colDef(name = "Percentile", align = "center")),
    compact = TRUE)
} else {
  print(no_movetimes_print)
}

```




##### Strength of schedule

These players faced the most in-form opponents across the season, when judged by their opponents' collective score in all their other games.^[Both the statistic and the name of its associated award -- the David Award -- were suggested by **Tranzoo**.]

*Includes all players who faced a collective group of opponents that played at least 15 (other) games across the season with a collective score above 50 per cent.*

```{r}
# Show David Award table
reactable(david,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
          compact = TRUE,
           columns = list(
    rank = colDef(name = "#", minWidth = 50),
    player = colDef(name = "Player", minWidth = 200),
    opp_games = colDef(name = "Opp Games", align = "center"),
    opp_points = colDef(name = "Opp Pts", align = "center"),
    opp_perc = colDef(name = "Opp %", align = "center", format = colFormat(digits = 0))
    )
)

```

#### Comebacks and upsets {.tabset .tabset-fade .tabset-pills} 

##### Comebacks

*Includes players with a positive average "comeback margin" that played at least three games.*^[Originally suggested by **Lou-E**. This table shows players ranked by the size and number of comebacks achieved over the course of the season. For this purpose, the size of a comeback has been defined as the difference between a player's final score in a game (0, 0.5, or 1) and the worst evaluation during the game that they faced (which is then converted into a rough win probability for their opponent). For example, if I were to win a game after Lichess's server analysis gave my opponent a 75% chance of winning in a certain position, then I would have earned 1.75 comeback "points" from the game. My opponent of course would have earned zero points. If the game had been drawn, I would have instead earned only 0.75 comeback "points".]

```{r comebacks}

reactable(comebacks_2,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
          compact = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center", minWidth = 50),
    player = colDef(name = "Player", minWidth = 200),
    avg_cb = colDef(name = "Average Comeback Margin", format = colFormat(digits = 2), align = "center"),
    total_cb = colDef(name = "Total Comeback Margin", format = colFormat(digits = 2), align = "center")
    )
)

```


##### Biggest upsets

*Includes all players who defeated an opponent rated at least 50 points higher.* 

```{r biggest_upsets}
reactable(upsets,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
          compact = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center", minWidth = 50),
    player = colDef(name = "Player", minWidth = 200),
    rating_gap = colDef(name = "Upset Margin", align = "center")
    )
)
```

##### Repeated upsets

Includes players who achieved multiple wins over opponents rated at least 50 points higher.

```{r}

reactable(upset_specialists,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
          compact = TRUE,
           columns = list(
             rank = colDef(name = "Rank", align = "center", minWidth = 50),
    player = colDef(name = "Player", minWidth = 200),
    upset_pts = colDef(name = "Total Upset Margin", align = "center"),
    upsets = colDef(name = "Upsets", align = "center"),
    mean_rating_gap = colDef(name = "Avg Upset Margin", align = "center", format = colFormat(digits = 1)),
    max_rating_gap = colDef(name = "Biggest Margin", align = "center")
    )
)

```



#### Dawdlers and instant movers {.tabset .tabset-fade .tabset-pills} 

##### Least time left after move 10

The players with the least time left after 10 moves...who still managed to win!^[Statistic suggested by **Silkthewanderer**.]

```{r other_grischuk, comment = ""}
if(movetimes_exist){
reactable(dawdlers,
          pagination = TRUE,
          searchable = TRUE,
          fullWidth = FALSE,
          resizable = TRUE,
          compact = TRUE,
          columns = list(
            rank = colDef(name = "Rank",
                          align = "center",
                          minWidth = 50),
            player = colDef(name = "Player", minWidth = 200),
            time_print = colDef(name = "Time left after 10 moves", minWidth = 120),
            url = colDef(name = "Link",
                           minWidth = 250,
                           html = TRUE, 
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', dawdlers$url[index], value)
          }),
          outcome = colDef(name = "Result", align = "center")))
} else {
  print(no_movetimes_print)
}
```



##### Instant moves 

Players who made the most 'instant' moves over the season, taking less than 0.5 seconds (includes premoves).

*Includes players with more than five 'instant' moves.*

```{r instamoves, comment = ""}
if(movetimes_exist){
reactable(instamovers,
          pagination = TRUE,
          searchable = TRUE,
          fullWidth = FALSE,
          resizable = TRUE,
          compact = TRUE,
          columns = list(
            rank = colDef(name = "Rank", align = "center", minWidth = 50),
            player = colDef(name = "Player", minWidth = 200),
            instamoves = colDef(name = "Instant moves", align = "center")
          ))
} else {
  print(no_movetimes_print)
}   
```

#### Longest thinks, time trouble addicts, and lucky escapes {.tabset .tabset-fade .tabset-pills} 

##### Longest thinks

The longest times spent on a single move.

*Top 100 shown.*

```{r, comment = ""}
if(movetimes_exist){
reactable(movetimes,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "#", align = "center"),
    player = colDef(name = "Player", minWidth = 200),
    time_spent = colDef(name = "Time spent"),
    colour = colDef(name = "Colour", align = "center"),
    move = colDef(name = "Move", align = "center"),
    url = colDef(name = "Link",
                           minWidth = 250,
                           html = TRUE, 
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', movetimes$url[index], value)
          })),
    compact = TRUE)
} else {
  print(no_movetimes_print)
}
```

##### Time trouble addicts

Shows players by proportion of moves made in time trouble (defined as having less than a minute remaining on the clock).

*Includes everyone who played at least 100 moves over the season while making at least one move in time trouble.*

```{r, comment = ""}

if(movetimes_exist){
reactable(timetrouble,
          pagination = TRUE, 
          fullWidth = FALSE,
          resizable = TRUE,
          searchable = TRUE,
           columns = list(
             rank = colDef(name = "#", align = "center"),
    player = colDef(name = "Player", minWidth = 200),
    moves = colDef(name = "All moves", align = "center"),
    tt_moves = colDef(name = "With < 1min left", align = "center"),
    tt_pc = colDef(name = "Time Trouble %",
                   align = "center",
                   format = colFormat(digits = 1, percent = TRUE))),
    compact = TRUE)
} else {
  print(no_movetimes_print)
}
```

##### Saved by the bell

Players who made moves with under 5 seconds left on their clock...and still won!^[Excludes moves made in technically winning positions, defined as $\tt eval \le 300$ (from the mover's perspective). Players are first ordered by number of moves made with 5 seconds or fewer remaining, then by least time remaining in such conditions, and finally by worst eval faced.]

```{r, comment = ""}
if(movetimes_exist){
reactable(savedbythebell,
          fullWidth = FALSE,
          resizable = TRUE,
          compact = TRUE,
          columns = list(
            player = colDef(name = "Player", minWidth = 200),
            panic_moves = colDef(name = "Moves with under 5s left", align = "center", minWidth = 110),
            min_time_left = colDef(name = "Least time left", align = "center", minWidth = 60),
            url = colDef(name = "Link",
                           minWidth = 250,
                           html = TRUE, 
                           cell = function(value, index){
            sprintf('<a href="%s" target="_blank">%s</a>', savedbythebell$url[index], value)
          })))
} else {
  print(no_movetimes_print)
}

```




####  Misc. facts {.tabset .tabset-fade .tabset-pills} 

##### Lesser spotted mates

```{r piece_checkmates}
# Checkmates by piece
mates <- tibble("id" = games$id,
                "mates" = rep(NA, nrow(games)))

for(i in seq(1:nrow(games))){
  mates$mates[i] <- str_extract(games$pgn[i], "\\s[:alnum:]+(?<!\\s)#") %>% str_squish()
}

mates <- mates %>% 
  filter(!(is.na(mates))) %>% 
  mutate(mating_piece = str_sub(mates, 1, 1))

all_mates <- mates %>% 
  mutate(status = replace(mating_piece, mating_piece %in% letters[1:8], "P")) %>%
  rename("piece" = status) %>%
  group_by(piece) %>% 
  tally() %>% 
  arrange(desc(n))

# all_mates %>% 
#   kable(caption = "Checkmates") %>% 
#   kableExtra::kable_classic(full_width = F, html_font = "arial", position = "left")
  
# List all games with pawn mates
pawn_mate_games <- mates %>% 
  filter(!(mating_piece %in% c("Q", "R", "B", "N"))) %>% 
  mutate(url = paste0("https://lichess.org/", id)) %>% 
  select(url) %>% 
  dplyr::pull()

knight_mate_games <- mates %>% 
  filter(mating_piece == "N") %>% 
  mutate(url = paste0("https://lichess.org/", id)) %>% 
  select(url) %>% 
  dplyr::pull()

```


A pawn gave checkmate in `r length(pawn_mate_games)` games: `r pawn_mate_games`.


A knight gave checkmate in `r length(knight_mate_games)` games: `r knight_mate_games`.

```{r, eval = FALSE, fig.show='hold',fig.align='center', out.width="45%", out.height="20%", fig.cap=c("v3U4K2uM", "1MWLzMll")}
# Show knight mate game positions
# SVGs saved in images/mates after running show_pawn_knight_mates.py
# Can work on this later, not necessary for now. 
knitr::include_graphics(c("images/mates/v3U4K2uM.svg", "images/mates/1MWLzMll.svg"))
```


##### Promotions

```{r promotions}
# Promotion stats
promotions <- tibble("url" = paste0("https://lichess.org/", games$id),
                       "promotions" = rep(0, nrow(games)),
                     "promotion_movetext" = rep(NA, nrow(games)))

promotion_moves <- str_extract_all(games$pgn, "[:alnum:]+(?<!\\s)=[:alnum:]")

for(i in seq(1:nrow(games))){
  promotions$promotions[i] <- length(promotion_moves[[i]])
  if(promotions$promotions[i] == 1){
    promotions$promotion_movetext[i] <- promotion_moves[[i]]
  }
  if(promotions$promotions[i] > 1){
    promotions$promotion_movetext[i] <- str_c(promotion_moves[[i]], collapse = " ")
  }
}

promotions <- promotions %>% 
  filter(promotions > 0) %>% 
  arrange(desc(promotions))

underpromotions <- promotions %>% 
  filter(str_detect(promotion_movetext, "N|B|R"))

most_promotions <- promotions %>% 
  slice_max(promotions) %>% 
  select(url) %>% 
  dplyr::pull()

```

`r nrow(promotions)` games had at least one promotion. `r nrow(underpromotions)` of these saw an under-promotion.

The most promotions seen in a game was `r max(promotions$promotions)`: `r most_promotions`

##### Rollercoaster games

```{r yoyos}
# Identify yo-yo games

# Collate all obtained move-level data
moves <- data.table::rbindlist(games$evals)

# Identify number yo-yo games
yoyos <- moves %>% 
  group_by(game_id) %>% 
  summarise(yoyo = ifelse(max(eval_scaled) > 0.75, ifelse(min(eval_scaled) < -0.75, TRUE, FALSE), FALSE)) %>% 
  filter(yoyo == TRUE) %>% 
  nrow()


```

`r yoyos` games featured significant winning chances for both sides (as identified by Lichess's server analysis), comprising `r round((yoyos / nrow(games)) * 100, 1)`% of all games played.

##### Checks and captures


```{r most_consecutive_checks}
# Find games with most consecutive checks and captures
lst_checks <- list()
lst_captures <- list()

for(i in seq(1:nrow(games))){
  
  checks <- tibble(url = rep(paste0("https://lichess.org/", games$id[i]), games$num_moves[i]),
                    move_num = seq(1:games$num_moves[i]),
                    white_text = rep("", games$num_moves[i]),
                    black_text = rep("", games$num_moves[i]))
  
  movetext <- str_extract_all(games$moves[i], "[:alpha:]+[:graph:]+")
  
  captures <- tibble(url = rep(paste0("https://lichess.org/", games$id[i]), length(movetext[[1]])),
                     ply_num = seq(1:length(movetext[[1]])),
                     text = movetext[[1]])
  
  if(length(movetext[[1]]) %% 2 == 1){movetext[[1]] <- c(movetext[[1]], NA)}
  
  checks$white_text <- movetext[[1]][c(T,F)]
  checks$black_text <- movetext[[1]][c(F,T)]
  
  lst_checks[[i]] <- checks
  lst_captures[[i]] <- captures
}

checks <- rbindlist(lst_checks)
captures <- rbindlist(lst_captures)

checks$is_check_w <- ifelse(str_detect(checks$white_text, "\\+"), 1, 0)
checks$is_check_b <- ifelse(str_detect(checks$black_text, "\\+"), 1, 0)

captures$is_capture <- ifelse(str_detect(captures$text, "x"), 1, 0)

# Isolate checks by colour
checks_w <- checks %>% 
  select(-c("black_text", "is_check_b")) %>% 
  rename("is_check" = "is_check_w")

checks_b <- checks %>% 
  select(-c("white_text", "is_check_w")) %>% 
  rename("is_check" = "is_check_b")

# For each colour set, find the games with the most consecutive checks

# White
check_streaks_w <- checks_w %>% 
  group_by(url) %>%
  do({tmp <- with(rle(.$is_check == T), lengths[values])
  data.frame(url = .$url, Max=if(length(tmp)==0) 0
             else max(tmp)) }) %>%
  slice(1L) %>%
  arrange(desc(Max)) %>%
  rename("streak" = Max) %>%
  as_tibble() %>%
  slice_max(streak)

# Black
check_streaks_b <- checks_b %>%
  group_by(url) %>%
  do({tmp <- with(rle(.$is_check == T), lengths[values])
  data.frame(url = .$url, Max=if(length(tmp)==0) 0
             else max(tmp)) }) %>%
  slice(1L) %>%
  arrange(desc(Max)) %>%
  rename("streak" = Max) %>%
  as_tibble() %>%
  slice_max(streak)

# Captures
capture_streaks <- captures %>%
  group_by(url) %>%
  do({tmp <- with(rle(.$is_capture == T), lengths[values])
  data.frame(url = .$url, Max=if(length(tmp)==0) 0
             else max(tmp)) }) %>%
  slice(1L) %>%
  arrange(desc(Max)) %>%
  rename("streak" = Max) %>%
  as_tibble() %>%
  slice_max(streak)

# Combine to get games with most consecutive checks by White and Black 
check_streaks <- bind_rows(check_streaks_w, check_streaks_b) %>% 
  arrange(desc(streak)) %>%
  slice_max(streak)

capture_streaks <- capture_streaks %>% 
  arrange(desc(streak)) %>%
  slice_max(streak)

check_streaks_games <- check_streaks %>% 
  select(url) %>% 
  dplyr::pull()

capture_streaks_games <- capture_streaks %>% 
  select(url) %>% 
  dplyr::pull()

# Find game with latest first capture
latest_first_capture <- captures %>%
  filter(is_capture == 1) %>% 
  group_by(url) %>% 
  summarise(first_capture = min(ply_num)) %>% 
  slice_max(first_capture)

game_latest_capture <- latest_first_capture %>% 
  select(url) %>% dplyr::pull()

```


- Most consecutive checks: `r max(check_streaks$streak)` (`r check_streaks_games`)
- Most consecutive captures: `r max(capture_streaks$streak)` (`r capture_streaks_games`)
- Latest-occurring first capture: ply `r max(latest_first_capture$first_capture)` in  `r game_latest_capture`

### About

:::about
- This report was compiled on `r format(Sys.time(), '%d %B %Y')`.
- These stats are presented for general interest only. They are not guaranteed to be comprehensive, complete, accurate, or up to date.
- This report may be revised periodically to incorporate minor updates and bugfixes.
- All stats based on game data deliberately exclude games involving players who were banned by Lichess (at any point up to `r format(Sys.time(), '%d %B %Y')`).^[Players who were banned after finishing a season in the top three places are still shown with a podium place in that season's report. However, their games and pairings are then removed from the season's data prior to any further analysis.] They also exclude games with fewer than 5 plies.
- Ties are not robustly handled when determining player awards, which may lead to the occasional mistake :)
- [Website](https://rahulan-c.github.io/lichess4545-stats/) / [source code](https://github.com/rahulan-c/lichess4545-stats)
- Acknowledgements: [Noun Project](https://thenounproject.com/) for the award icons; [Simon Ilincev](https://simonilincev.com/) for [chess_graph](https://github.com/Destaq/chess_graph), which produces the openings sunburst plots.
:::


